<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engineering Calculation Merger</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF-Lib Engine (Required for PDF manipulation) -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <!-- PDF.js Engine (Required for rendering preview) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Initialize PDF.js Worker immediately
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Font (Noto Sans for consistency) -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Firebase SDKs (v11.6.1) -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, addDoc, deleteDoc, query, orderBy } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject, listAll, getMetadata, getBytes } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js';
    </script>

    <style>
        body { font-family: 'Noto Sans', sans-serif; }
        /* Custom scrollbar for preview pane */
        .preview-scroll::-webkit-scrollbar { width: 8px; height: 8px; }
        .preview-scroll::-webkit-scrollbar-track { background: #f1f5f9; }
        .preview-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .preview-scroll::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        /* Drag ghost image fix */
        .drag-ghost { opacity: 0.5; background: white; border: 1px solid #ccc; }
    </style>
</head>
<body class="bg-slate-100 overflow-hidden"> 
    <div id="root" class="h-screen flex flex-col"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module">
        // Import React
        import React, { useState, useRef, useMemo, useEffect } from 'https://esm.sh/react@18.2.0';
        import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
        
        // Import Icons
        import { 
            Upload, FileText, ArrowUp, ArrowDown, ArrowRight, ArrowLeft, 
            Trash2, Save, FilePlus, Settings, Eye, AlertCircle, List, 
            Calendar, User, Hash, AlignLeft, AlignCenter, AlignRight, 
            CheckSquare, Clock, Image as ImageIcon, X, FileQuestion, 
            RefreshCw, Cloud, Check, Loader2, WifiOff, Lock, Key, 
            RotateCcw, AlertTriangle, HelpCircle, HardDrive, Database,
            FolderPlus, FolderOpen, MoreVertical, Layout, LogOut, Users, 
            ZapOff, Globe, Book, PenTool, ClipboardList, Type, Copy, 
            GripVertical, Maximize2, ExternalLink, ChevronLeft, ChevronRight
        } from 'https://esm.sh/lucide-react@0.263.1';

        // --- FIREBASE IMPORTS (v11.6.1) ---
        import { initializeApp, deleteApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, addDoc, deleteDoc, query, orderBy } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject, listAll, getMetadata, getBytes } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js';

        // --- GLOBAL CONFIGURATION DETECTION ---
        let firebaseConfig = null;
        let isConfigured = false;
        let isOfflineMode = false;
        let appId = 'default';
        let initialAuthToken = null;

        if (typeof __firebase_config !== 'undefined') {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
                isConfigured = true;
                if (typeof __app_id !== 'undefined') appId = __app_id;
                if (typeof __initial_auth_token !== 'undefined') initialAuthToken = __initial_auth_token;
            } catch(e) { console.error("Env Config Parse Error", e); }
        }

        if (!isConfigured) {
            const savedConfig = localStorage.getItem('calcBinder_firebaseConfig');
            if (savedConfig === 'offline') {
                isOfflineMode = true;
                isConfigured = true;
            } else if (savedConfig) {
                try {
                    firebaseConfig = JSON.parse(savedConfig);
                    if (firebaseConfig.apiKey && firebaseConfig.projectId) {
                        isConfigured = true;
                        appId = firebaseConfig.appId || 'default';
                    }
                } catch (e) {
                    localStorage.removeItem('calcBinder_firebaseConfig');
                }
            }
        }

        let app, auth, db, storage;
        if (isConfigured && !isOfflineMode && firebaseConfig) {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                storage = getStorage(app);
            } catch (e) {
                console.error("Firebase Init Failed", e);
                isConfigured = false;
            }
        }

        // --- UTILS: DEEP COMPARE ---
        const isEqual = (a, b) => {
            if (a === b) return true;
            if (a && b && typeof a === 'object' && typeof b === 'object') {
                if (Array.isArray(a) !== Array.isArray(b)) return false;
                const keys = Object.keys(a);
                if (keys.length !== Object.keys(b).length) return false;
                return keys.every(key => b.hasOwnProperty(key) && isEqual(a[key], b[key]));
            }
            return false;
        };

        // --- ERROR BOUNDARY ---
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) { return { hasError: true, error }; }
            handleReset = () => { localStorage.removeItem('calcBinder_firebaseConfig'); window.location.reload(); }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="min-h-screen flex items-center justify-center bg-red-50 p-8 text-center">
                            <div className="bg-white p-8 rounded-lg shadow-xl max-w-md border border-red-100">
                                <AlertTriangle className="w-12 h-12 text-red-500 mx-auto mb-4" />
                                <h1 className="text-xl font-bold text-red-700 mb-2">Critical Error</h1>
                                <div className="bg-slate-100 p-2 rounded text-xs font-mono text-left mb-6 overflow-auto max-h-32">{this.state.error && this.state.error.toString()}</div>
                                <button onClick={this.handleReset} className="w-full py-2 bg-red-600 text-white rounded font-semibold hover:bg-red-700 transition-colors flex items-center justify-center gap-2"><RotateCcw className="w-4 h-4" /> Reset Configuration</button>
                            </div>
                        </div>
                    );
                }
                return this.props.children; 
            }
        }

        // --- COMPONENT: PDF CANVAS PREVIEW ---
        // This replaces the <object> tag to ensure rendering in sandboxed environments
        const PdfCanvasPreview = ({ pdfData }) => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [pdfDoc, setPdfDoc] = useState(null);
            const [pageNum, setPageNum] = useState(1);
            const [numPages, setNumPages] = useState(0);
            const [baseWidth, setBaseWidth] = useState(0);
            const [renderError, setRenderError] = useState(null);

            // 1. Load Document
            useEffect(() => {
                if (!pdfData) return;
                const loadTask = window.pdfjsLib.getDocument({ data: pdfData });
                loadTask.promise.then(doc => {
                    setPdfDoc(doc);
                    setNumPages(doc.numPages);
                    setPageNum(1);
                    setRenderError(null);
                }, err => {
                    console.error("PDF Load Error", err);
                    setRenderError("Failed to load PDF data.");
                });
                return () => { if(loadTask) loadTask.destroy(); }
            }, [pdfData]);

            // 2. Measure Container (Resize Observer)
            useEffect(() => {
                if (!containerRef.current) return;
                
                const updateWidth = () => {
                    if (containerRef.current && containerRef.current.parentElement) {
                        // Measure parent to avoid scrollbar loop issues
                        setBaseWidth(containerRef.current.parentElement.clientWidth - 48); // 48px padding
                    }
                };
                
                updateWidth();
                window.addEventListener('resize', updateWidth);
                
                const observer = new ResizeObserver(updateWidth);
                if (containerRef.current.parentElement) {
                    observer.observe(containerRef.current.parentElement);
                }

                return () => {
                    window.removeEventListener('resize', updateWidth);
                    observer.disconnect();
                };
            }, []);

            // 3. Render Page
            useEffect(() => {
                if (!pdfDoc || !canvasRef.current || baseWidth === 0) return;
                
                let renderTask = null;

                const renderPage = async () => {
                    try {
                        const page = await pdfDoc.getPage(pageNum);
                        
                        // Get unscaled viewport (1.0 scale) to determine intrinsic width
                        const unscaledViewport = page.getViewport({ scale: 1.0 });
                        
                        // Calculate "Fit Width" scale based on the STABLE baseWidth
                        const fitScale = baseWidth / unscaledViewport.width;
                        
                        // Use only fitScale (Zoom removed)
                        const viewport = page.getViewport({ scale: Math.max(0.1, fitScale) });

                        const canvas = canvasRef.current;
                        const context = canvas.getContext('2d');
                        
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        const renderContext = {
                            canvasContext: context,
                            viewport: viewport
                        };
                        
                        renderTask = page.render(renderContext);
                        await renderTask.promise;
                    } catch (err) {
                        if (err.name !== 'RenderingCancelledException') {
                            console.error("Render error", err);
                        }
                    }
                };
                renderPage();
                
                return () => { if (renderTask) renderTask.cancel(); };
            }, [pdfDoc, pageNum, baseWidth]); // Removed userZoom dependency

            if (renderError) return <div className="text-red-500 p-4 text-center text-xs">{renderError}</div>;

            return (
                <div className="flex flex-col items-center w-full h-full bg-slate-300 overflow-hidden relative">
                    <div ref={containerRef} className="flex-1 overflow-auto w-full flex justify-center p-6">
                        <canvas ref={canvasRef} className="shadow-lg bg-white" />
                    </div>
                    {numPages > 0 && (
                        <div className="absolute bottom-4 z-50 bg-white/90 backdrop-blur shadow-md rounded-full px-4 py-2 flex items-center gap-4 text-sm font-medium text-slate-700 transition-opacity hover:opacity-100 border border-slate-200">
                            <button onClick={() => setPageNum(p => Math.max(1, p - 1))} disabled={pageNum<=1} className="hover:text-blue-600 disabled:opacity-30"><ChevronLeft className="w-4 h-4" /></button>
                            <span className="min-w-[80px] text-center">Page {pageNum} / {numPages}</span>
                            <button onClick={() => setPageNum(p => Math.min(numPages, p + 1))} disabled={pageNum>=numPages} className="hover:text-blue-600 disabled:opacity-30"><ChevronRight className="w-4 h-4" /></button>
                        </div>
                    )}
                </div>
            );
        };


        // --- COMPONENTS ---

        const OutputConfigModal = ({ onClose, pageNumberPos, setPageNumberPos, totalFiles }) => {
            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
                    <div className="bg-white rounded-lg shadow-xl w-full max-w-md p-6">
                        <div className="flex justify-between items-center mb-4 border-b border-slate-100 pb-2">
                            <h3 className="font-bold text-slate-800 flex items-center gap-2"><Settings className="w-5 h-5 text-blue-600" /> Output Settings</h3>
                            <button onClick={onClose} className="p-1 hover:bg-slate-100 rounded-full text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button>
                        </div>
                        
                        <div className="space-y-6">
                            <div>
                                <label className="text-xs font-bold text-slate-500 uppercase block mb-2">Page Numbering Position</label>
                                <div className="flex bg-slate-100 p-1 rounded-md">
                                    <button onClick={() => setPageNumberPos('left')} className={`flex-1 py-2 rounded text-sm font-medium transition-all ${pageNumberPos==='left'?'bg-white shadow text-blue-600':'text-slate-500 hover:text-slate-700'}`}><div className="flex items-center justify-center gap-2"><AlignLeft className="w-4 h-4" /> Left</div></button>
                                    <button onClick={() => setPageNumberPos('center')} className={`flex-1 py-2 rounded text-sm font-medium transition-all ${pageNumberPos==='center'?'bg-white shadow text-blue-600':'text-slate-500 hover:text-slate-700'}`}><div className="flex items-center justify-center gap-2"><AlignCenter className="w-4 h-4" /> Center</div></button>
                                    <button onClick={() => setPageNumberPos('right')} className={`flex-1 py-2 rounded text-sm font-medium transition-all ${pageNumberPos==='right'?'bg-white shadow text-blue-600':'text-slate-500 hover:text-slate-700'}`}><div className="flex items-center justify-center gap-2"><AlignRight className="w-4 h-4" /> Right</div></button>
                                </div>
                            </div>

                            <div className="space-y-3">
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-2"><input type="checkbox" checked disabled className="rounded text-blue-600 focus:ring-blue-500" /><span className="text-sm text-slate-700 font-medium">Table of Contents</span></div>
                                    <span className="text-xs text-slate-400 bg-slate-100 px-2 py-0.5 rounded">Auto-Generated</span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-2"><input type="checkbox" defaultChecked className="rounded text-blue-600 focus:ring-blue-500" /><span className="text-sm text-slate-700 font-medium">Section Dividers</span></div>
                                    <span className="text-xs text-slate-400 bg-slate-100 px-2 py-0.5 rounded">Enabled</span>
                                </div>
                            </div>
                            
                            <div className="pt-4 border-t border-slate-100 text-center">
                                <span className="text-xs text-slate-400">Total Sections Included: <span className="font-mono font-bold text-slate-600">{totalFiles}</span></span>
                            </div>

                            <button onClick={onClose} className="w-full py-2 bg-slate-800 text-white rounded font-medium hover:bg-slate-900 transition-colors">Done</button>
                        </div>
                    </div>
                </div>
            );
        }

        // Detailed Cover Sheet Modal
        const CoverSheetModal = ({ file, projectMeta, onClose, onSave }) => {
            const [data, setData] = useState({
                sectionTitle: file.sectionTitle || "",
                sectionSubtitle: file.sectionSubtitle || "",
                designedBy: file.designedBy || file.calcsBy || "",
                designedDate: file.designedDate || file.uploadDate || "",
                checkedBy: file.checkedBy || "",
                checkedDate: file.checkedDate || "",
                qcReviewBy: file.qcReviewBy || file.reviewedBy || file.qcBy || "",
                qcReviewDate: file.qcReviewDate || file.reviewedDate || file.qcDate || "",
                approvedBy: file.approvedBy || "",
                approvedDate: file.approvedDate || "",
                revision: file.revision || "0",
                calcNo: file.calcNo || "",
            });

            const [customFields, setCustomFields] = useState((file.customFields || [
                { id: 1, label: "Objective / Scope", value: file.objective || "", isVisible: true },
                { id: 2, label: "Design Code / References", value: file.references || "", isVisible: true },
                { id: 3, label: "Computer Program", value: file.program || "", isVisible: true },
                { id: 4, label: "Conclusions", value: file.conclusions || "", isVisible: true }
            ]).map(f => ({ ...f, isEditingLabel: false })));

            const handleChange = (field, value) => { setData(prev => ({ ...prev, [field]: value })); };
            const handleCustomFieldChange = (index, key, val) => {
                const newFields = [...customFields];
                newFields[index][key] = val;
                setCustomFields(newFields);
            };
            const handleSave = () => {
                const cleanFields = customFields.map(({ isEditingLabel, ...rest }) => rest);
                onSave(file.id, { ...data, customFields: cleanFields });
                onClose();
            };

            const renderSignOffRow = (label, fieldPrefix) => (
                <div className="grid grid-cols-12 gap-2 items-center">
                    <div className="col-span-4 text-xs font-semibold text-slate-500 uppercase">{label}</div>
                    <div className="col-span-5"><input type="text" className="w-full border border-slate-300 rounded p-1.5 text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="Name/Initials" value={data[`${fieldPrefix}By`]} onChange={e => handleChange(`${fieldPrefix}By`, e.target.value)} /></div>
                    <div className="col-span-3"><input type="date" className="w-full border border-slate-300 rounded p-1.5 text-sm focus:ring-2 focus:ring-blue-500 outline-none" value={data[`${fieldPrefix}Date`]} onChange={e => handleChange(`${fieldPrefix}Date`, e.target.value)} /></div>
                </div>
            );

            return (
                <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl flex flex-col max-h-[90vh]">
                        <div className="flex justify-between items-center p-6 border-b border-slate-100 bg-slate-50 rounded-t-xl"><h2 className="text-xl font-bold text-slate-800 flex items-center gap-2"><ClipboardList className="w-6 h-6 text-blue-600" /> Calculation Cover Sheet</h2><button onClick={onClose} className="p-2 hover:bg-slate-200 rounded-full transition-colors text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button></div>
                        <div className="p-6 overflow-y-auto space-y-6">
                            <div className="grid grid-cols-2 gap-4 p-3 bg-blue-50 border border-blue-100 rounded-lg text-sm text-blue-800"><div><span className="font-bold uppercase text-[10px] text-blue-400 block">Project</span> {projectMeta.title}</div><div><span className="font-bold uppercase text-[10px] text-blue-400 block">Project No</span> {projectMeta.number}</div></div>
                            <div className="space-y-4"><h3 className="text-sm font-bold uppercase text-slate-400 tracking-wider border-b border-slate-100 pb-1">Identification</h3><div className="grid grid-cols-12 gap-4"><div className="col-span-12"><label className="block text-xs font-semibold text-slate-500 mb-1">Title</label><input type="text" className="w-full border border-slate-300 rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none" value={data.sectionTitle} onChange={e => handleChange('sectionTitle', e.target.value)} /></div><div className="col-span-12"><label className="block text-xs font-semibold text-slate-500 mb-1">Subtitle / Element</label><input type="text" className="w-full border border-slate-300 rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="e.g. Pier 3 Cap Design" value={data.sectionSubtitle} onChange={e => handleChange('sectionSubtitle', e.target.value)} /></div></div></div>
                            <div className="space-y-4"><h3 className="text-sm font-bold uppercase text-slate-400 tracking-wider border-b border-slate-100 pb-1">Technical Details</h3><div className="space-y-3">{customFields.map((field, index) => (<div key={index} className="flex gap-3 items-start bg-slate-50 p-3 rounded-lg border border-slate-100 group"><div className="pt-3"><input type="checkbox" checked={field.isVisible} onChange={e => handleCustomFieldChange(index, 'isVisible', e.target.checked)} className="w-4 h-4 text-blue-600 rounded border-slate-300 focus:ring-blue-500" title={`Include "${field.label}" on Divider Sheet`} /></div><div className="flex-1 space-y-1"><div className="flex items-center justify-between h-6">{field.isEditingLabel ? (<div className="flex items-center gap-2 w-full"><input autoFocus type="text" value={field.label} onChange={e => handleCustomFieldChange(index, 'label', e.target.value)} onBlur={() => handleCustomFieldChange(index, 'isEditingLabel', false)} onKeyDown={(e) => { if (e.key === 'Enter') handleCustomFieldChange(index, 'isEditingLabel', false) }} className="w-full text-xs font-bold text-slate-700 bg-white border border-blue-400 rounded px-1.5 py-0.5 outline-none uppercase tracking-wide shadow-sm" /><button onMouseDown={(e) => e.preventDefault()} onClick={() => handleCustomFieldChange(index, 'isEditingLabel', false)} className="p-1 text-green-600 hover:bg-green-50 rounded"><Check className="w-3 h-3" /></button></div>) : (<div className="flex items-center gap-2"><span className={`text-xs font-bold text-slate-500 uppercase tracking-wide select-none ${!field.isVisible && 'opacity-50'}`}>{field.label}</span>{field.isVisible && (<button onClick={() => handleCustomFieldChange(index, 'isEditingLabel', true)} className="p-1 text-slate-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors" title="Rename Header"><PenTool className="w-3 h-3" /></button>)}</div>)}</div><textarea rows={2} maxLength={2500} value={field.value} onChange={e => handleCustomFieldChange(index, 'value', e.target.value)} className={`w-full border rounded p-2 text-sm outline-none resize-none transition-colors ${!field.isVisible ? 'text-slate-400 bg-slate-100 border-slate-200' : 'bg-white border-slate-300 focus:ring-2 focus:ring-blue-500'}`} placeholder="Enter details..." disabled={!field.isVisible} />{field.isVisible && <div className="text-[10px] text-right text-slate-400">{field.value.length}/2500</div>}</div></div>))}</div></div>
                            <div className="space-y-4"><h3 className="text-sm font-bold uppercase text-slate-400 tracking-wider border-b border-slate-100 pb-1">Sign-off</h3><div className="space-y-2 bg-slate-50 p-3 rounded-lg border border-slate-100"><div className="grid grid-cols-12 gap-2 mb-1 text-[10px] uppercase font-bold text-slate-400"><div className="col-span-4">Role</div><div className="col-span-5">Name</div><div className="col-span-3">Date</div></div>{renderSignOffRow("Designed By", "designed")}{renderSignOffRow("Checked By", "checked")}{renderSignOffRow("QC Review By", "qcReview")}</div><div className="flex items-center gap-2 justify-end"><label className="text-xs font-semibold text-slate-500">Revision:</label><input type="text" className="w-16 border border-slate-300 rounded p-1 text-sm text-center focus:ring-2 focus:ring-blue-500 outline-none" value={data.revision} onChange={e => handleChange('revision', e.target.value)} /></div></div>
                        </div>
                        <div className="p-4 border-t border-slate-200 bg-slate-50 rounded-b-xl flex justify-end gap-2"><button onClick={onClose} className="px-4 py-2 text-slate-600 font-medium hover:bg-slate-200 rounded transition-colors">Cancel</button><button onClick={handleSave} className="px-4 py-2 bg-blue-600 text-white font-medium hover:bg-blue-700 rounded shadow-sm transition-colors flex items-center gap-2"><Check className="w-4 h-4" /> Save Details</button></div>
                    </div>
                </div>
            );
        };

        const CorsHelpModal = ({ onClose }) => (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6 relative">
                    <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button>
                    <h2 className="text-xl font-bold text-slate-900 mb-4 flex items-center gap-2"><Globe className="w-6 h-6 text-blue-600" /> Fixing Download Errors (CORS)</h2>
                    <div className="prose prose-sm text-slate-600 max-h-[60vh] overflow-y-auto">
                        <p>If you see "Failed to fetch" errors when generating PDFs, Google Storage is blocking the browser from downloading the file. You must configure CORS on your bucket.</p>
                        <ol className="list-decimal pl-5 space-y-2">
                            <li>Go to the <a href="https://console.cloud.google.com/" target="_blank" className="text-blue-600 hover:underline">Google Cloud Console</a>.</li>
                            <li>Open the Cloud Shell (terminal icon in top right).</li>
                            <li>Create a config file: <code>nano cors.json</code></li>
                            <li>Paste this configuration: <pre className="bg-slate-100 p-2 rounded text-xs mt-1">{`[\n  {\n    "origin": ["*"],\n    "method": ["GET"],\n    "maxAgeSeconds": 3600\n  }\n]`}</pre></li>
                            <li>Save (Ctrl+O, Enter) and Exit (Ctrl+X).</li>
                            <li>Run this command (replace <code>YOUR_BUCKET_NAME</code> with the 'storageBucket' from your config): <pre className="bg-slate-100 p-2 rounded text-xs mt-1 font-bold">gsutil cors set cors.json gs://YOUR_BUCKET_NAME</pre></li>
                        </ol>
                        <p className="text-xs italic mt-2">Note: This allows any website to download your public files. For tighter security, replace <code>*</code> with your specific domain.</p>
                    </div>
                </div>
            </div>
        );

        const SetupScreen = ({ onSave }) => { 
            const [configInput, setConfigInput] = useState('');
            const [error, setError] = useState('');
            const [isTesting, setIsTesting] = useState(false);
            const handleSave = async () => {
                setError(''); setIsTesting(true);
                try {
                    let input = configInput.trim().replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').replace(/^(const|var|let)\s+\w+\s*=\s*/, '').replace(/;$/, '');
                    let config;
                    try { config = JSON.parse(input); } catch (jsonErr) { try { config = new Function('return ' + input)(); } catch (evalErr) { throw new Error("Could not parse text. Ensure you copied the full object { ... }."); } }
                    if (!config || !config.apiKey || !config.projectId) throw new Error("Invalid Config: Missing 'apiKey' or 'projectId'.");
                    try {
                        const tempApp = initializeApp(config, "testConnectionApp");
                        const tempAuth = getAuth(tempApp);
                        await signInAnonymously(tempAuth);
                        deleteApp(tempApp); 
                    } catch (connErr) {
                        console.warn("Test connection warning:", connErr);
                        if (connErr.code === 'auth/invalid-api-key') throw new Error("Invalid API Key. Please check your project settings.");
                    }
                    localStorage.setItem('calcBinder_firebaseConfig', JSON.stringify(config));
                    onSave();
                } catch (e) { setError(e.message); } finally { setIsTesting(false); }
            };
            const handleOffline = () => { localStorage.setItem('calcBinder_firebaseConfig', 'offline'); onSave(); };
            return (
                <div className="min-h-screen bg-slate-50 flex items-center justify-center p-4 font-sans">
                    <div className="bg-white max-w-md w-full p-8 rounded-xl shadow-lg border border-slate-200">
                        <div className="flex justify-center mb-6"><div className="w-16 h-16 bg-blue-50 rounded-full flex items-center justify-center"><Lock className="w-8 h-8 text-blue-600" /></div></div>
                        <h1 className="text-2xl font-bold text-center text-slate-900 mb-2">Connect to Cloud</h1>
                        <p className="text-center text-slate-500 mb-6 text-sm">Paste your <strong>Firebase Config</strong> to enable cloud features.<br/><span className="text-xs text-slate-400">Ensure Anonymous Auth is enabled in Console.</span></p>
                        <div className="bg-slate-50 p-4 rounded border border-slate-200 mb-4"><label className="block text-xs font-bold text-slate-400 uppercase mb-2">Firebase Config Object</label><textarea className="w-full h-32 bg-white border border-slate-300 rounded p-2 text-xs font-mono focus:ring-2 focus:ring-blue-500 outline-none" placeholder='{ "apiKey": "...", "projectId": "...", ... }' value={configInput} onChange={(e) => setConfigInput(e.target.value)} /></div>
                        {error && <div className="flex items-start gap-2 text-red-600 text-xs mb-4 bg-red-50 p-2 rounded"><AlertCircle className="w-4 h-4 mt-0.5 shrink-0" /><span>{error}</span></div>}
                        <div className="space-y-3"><button onClick={handleSave} disabled={isTesting} className={`w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg transition-colors flex items-center justify-center gap-2 ${isTesting ? 'opacity-70 cursor-not-allowed' : ''}`}>{isTesting ? <Loader2 className="w-4 h-4 animate-spin" /> : <Key className="w-4 h-4" />} {isTesting ? "Testing Connection..." : "Verify & Save"}</button><div className="relative flex py-2 items-center"><div className="flex-grow border-t border-slate-200"></div><span className="flex-shrink-0 mx-4 text-xs text-slate-400 font-medium">OR</span><div className="flex-grow border-t border-slate-200"></div></div><button onClick={handleOffline} className="w-full py-3 bg-white border-2 border-slate-200 hover:border-slate-300 text-slate-600 font-bold rounded-lg transition-colors flex items-center justify-center gap-2"><ZapOff className="w-4 h-4" /> Skip Setup (Work Offline)</button></div>
                    </div>
                </div>
            );
        };

        const CalcBinder = () => {
            const [user, setUser] = useState(null);
            const [syncStatus, setSyncStatus] = useState(isOfflineMode ? 'offline' : 'connecting'); 
            const [authError, setAuthError] = useState(null);
            const [showCorsHelp, setShowCorsHelp] = useState(false);
            const [editingFile, setEditingFile] = useState(null); // File object for modal
            const [showConfigModal, setShowConfigModal] = useState(false); // Config Modal State
            
            // --- Multi-Project State ---
            const [projects, setProjects] = useState([]);
            const [activeProjectId, setActiveProjectId] = useState(null);
            
            // --- Current Project Data ---
            const [files, setFiles] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [storageStats, setStorageStats] = useState({ usedBytes: 0, fileCount: 0 });
            const [refreshStats, setRefreshStats] = useState(0); 
            const [pdfData, setPdfData] = useState(null); // CHANGED: Store Uint8Array instead of URL

            // --- Drag State ---
            const [dragItem, setDragItem] = useState(null); // { index: number, x: number }
            const [dragOverIndex, setDragOverIndex] = useState(null);
            const [isDraggingFile, setIsDraggingFile] = useState(false);

            const [projectMeta, setProjectMeta] = useState({
                title: "Structural Calculation Package",
                number: "2025-001",
                client: "Client Name",
                date: new Date().toISOString().split('T')[0],
                description: "Structural analysis and design of primary framing members.",
                docType: "CALCULATION PACKAGE" 
            });

            const [logo, setLogo] = useState(null); 
            const [logoUrl, setLogoUrl] = useState(null); 
            const [logoScale, setLogoScale] = useState("1.0"); 
            const [pageNumberPos, setPageNumberPos] = useState('right');
            const [autoUpdate, setAutoUpdate] = useState(false); // Default OFF to stabilize

            const [pdfLibLoaded, setPdfLibLoaded] = useState(false);
            const fileInputRef = useRef(null);
            const logoInputRef = useRef(null);

            // Create a Ref to track activeProjectId for listeners without stale closures
            const activeProjectIdRef = useRef(activeProjectId);
            
            // Keep ref in sync
            useEffect(() => {
                activeProjectIdRef.current = activeProjectId;
            }, [activeProjectId]);

            useEffect(() => {
                const loadPdfLib = async () => {
                    if (window.PDFLib) { setPdfLibLoaded(true); return; }
                    try {
                        // PDFLib is loaded via script tag, wait for window check
                        const check = setInterval(() => {
                            if(window.PDFLib) {
                                setPdfLibLoaded(true);
                                clearInterval(check);
                            }
                        }, 500);
                        setTimeout(() => clearInterval(check), 5000);
                    } catch (err) { console.error(err); }
                };
                loadPdfLib();
            }, []);

            // --- AUTH & PROJECTS LISTENER ---
            useEffect(() => {
                if (isOfflineMode) {
                    setProjects([{id: 'offline', projectMeta: { title: "Offline Project" }, lastModified: new Date().toISOString() }]);
                    setActiveProjectId('offline');
                    return;
                }

                // Auth Logic incorporating Custom Tokens (for Canvas) and Anonymous fallback
                const initAuth = async () => {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                         setSyncStatus('offline');
                         setAuthError("Auth Failed: " + error.message);
                    }
                };
                initAuth();

                const unsubscribe = onAuthStateChanged(auth, async (currentUser) => {
                    if (currentUser) {
                        setUser(currentUser);
                        setSyncStatus('synced');
                        setAuthError(null);
                        
                        // Strict Rule: No complex queries. Fetch all projects then sort in memory if needed.
                        const projectsRef = collection(db, "artifacts", appId, "public", "data", "projects");
                        
                        // Using simple query
                        const unsubProjects = onSnapshot(projectsRef, (snapshot) => {
                            const projList = snapshot.docs.map(doc => ({
                                id: doc.id,
                                ...doc.data()
                            })).sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified)); // Sort in memory

                            setProjects(projList);
                            
                            // BUG FIX: Use the REF, not state, to check current selection.
                            // Only auto-select if NO project is selected, OR if the currently selected project was deleted.
                            const currentId = activeProjectIdRef.current;
                            
                            if (projList.length > 0) {
                                if (!currentId) {
                                    // Initial load: select first
                                    setActiveProjectId(projList[0].id);
                                } else {
                                    // Check if current still exists
                                    const stillExists = projList.find(p => p.id === currentId);
                                    if (!stillExists) {
                                        // It was deleted, fallback to first
                                        setActiveProjectId(projList[0].id);
                                    }
                                    // If it exists, DO NOTHING. Keep current selection.
                                }
                            } else if (projList.length === 0) {
                                handleCreateProject(currentUser.uid, "New Shared Project");
                            }
                        }, (error) => {
                            setAuthError("Database Access Denied. Check Rules.");
                        });
                        return () => unsubProjects();
                    }
                });
                return () => unsubscribe();
            }, []);

            // --- ACTIVE PROJECT DATA LISTENER (PATCHED) ---
            useEffect(() => {
                if (isOfflineMode || !user || !activeProjectId) return;

                const docRef = doc(db, "artifacts", appId, "public", "data", "projects", activeProjectId);
                const unsubDoc = onSnapshot(docRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        
                        // 1. Project Meta Update (with strict comparison)
                        if (data.projectMeta) {
                            setProjectMeta(prev => {
                                if (isEqual(prev, data.projectMeta)) return prev;
                                return data.projectMeta;
                            });
                        }

                        // 2. Files Update (with strict comparison)
                        if (data.files) {
                            setFiles(prev => {
                                const cloudFiles = data.files || [];
                                // Prepare local version for comparison by stripping blobs
                                const prevClean = prev.map(({ fileObj, ...rest }) => rest);
                                
                                if (isEqual(prevClean, cloudFiles)) {
                                    return prev;
                                }

                                // Merge cloud data with local file objects
                                return cloudFiles.map(cf => {
                                    const localMatch = prev.find(lf => lf.id === cf.id);
                                    return { 
                                        ...cf, 
                                        fileObj: localMatch?.fileObj || null 
                                    };
                                });
                            });
                        }

                        // 3. Settings Updates
                        if (data.logoUrl) setLogoUrl(prev => prev === data.logoUrl ? prev : data.logoUrl);
                        if (data.logoScale !== undefined) setLogoScale(prev => prev === data.logoScale.toString() ? prev : data.logoScale.toString());
                        if (data.pageNumberPos) setPageNumberPos(prev => prev === data.pageNumberPos ? prev : data.pageNumberPos);
                        
                        setSyncStatus('synced');
                    }
                }, (err) => {
                    console.error("Project fetch error", err);
                });
                return () => unsubDoc();
            }, [user, activeProjectId]);

            // --- Storage Usage ---
            useEffect(() => {
                if (isOfflineMode || !user) return;
                const calculateUsage = async () => {
                    try {
                        const filesRef = ref(storage, `artifacts/${appId}/public/data/files`);
                        // Note: listAll only works if rules allow list. 
                        // If this fails, we just don't show stats.
                        const listResult = await listAll(filesRef);
                        let totalBytes = 0;
                        let count = 0;
                        const metadataPromises = listResult.items.map(itemRef => getMetadata(itemRef));
                        const metaResults = await Promise.all(metadataPromises);
                        metaResults.forEach(meta => { totalBytes += meta.size; count++; });
                        setStorageStats({ usedBytes: totalBytes, fileCount: count });
                    } catch (e) { 
                        // Silent fail for stats
                    }
                };
                calculateUsage();
            }, [user, refreshStats, syncStatus]);

            // --- Auto-Save ---
            useEffect(() => {
                if (isOfflineMode) return; 
                const saveData = async () => {
                    if (user && activeProjectId && syncStatus !== 'connecting' && syncStatus !== 'error') {
                        setSyncStatus('syncing');
                        try {
                            const docRef = doc(db, "artifacts", appId, "public", "data", "projects", activeProjectId);
                            const cleanFiles = files.map(f => {
                                const { fileObj, ...rest } = f; 
                                return rest;
                            });
                            await setDoc(docRef, {
                                projectMeta,
                                files: cleanFiles,
                                logoUrl,
                                logoScale: parseFloat(logoScale) || 1.0,
                                pageNumberPos,
                                lastModified: new Date().toISOString(),
                                modifiedBy: user.uid
                            }, { merge: true });
                            setSyncStatus('synced');
                        } catch (e) {
                            console.error("Cloud save failed", e);
                            setSyncStatus('error');
                        }
                    }
                };
                const timeout = setTimeout(saveData, 2000);
                return () => clearTimeout(timeout);
            }, [files, projectMeta, logoUrl, logoScale, pageNumberPos, user, syncStatus, activeProjectId]);

            // --- Auto-Preview Effect (Debounced) ---
            useEffect(() => {
                if (!autoUpdate || files.length === 0) return;
                
                const timer = setTimeout(() => {
                    generateBinder('preview', true); // true = silent/auto mode
                }, 1500); // 1.5s delay after last change

                return () => clearTimeout(timer);
            }, [files, projectMeta, logoUrl, logoScale, pageNumberPos, autoUpdate]);

            // --- INITIAL AUTO-LOAD EFFECT ---
            // Trigger preview generation once when files are loaded and PDF lib is ready
            useEffect(() => {
                // Ensure PDF lib is ready, files exist, and we haven't generated yet (pdfData is null)
                if (pdfLibLoaded && files.length > 0 && !pdfData && !isProcessing) {
                    // Use a small timeout to ensure state is settled
                    const t = setTimeout(() => {
                        generateBinder('preview', true);
                    }, 500);
                    return () => clearTimeout(t);
                }
            }, [pdfLibLoaded, files, pdfData, isProcessing]);


            // --- PROJECT ACTIONS ---
            const handleCreateProject = async (uid, title = "New Shared Project") => {
                if (isOfflineMode) return;
                if (!uid) return;
                const newProject = {
                    projectMeta: { ...projectMeta, title: title, number: "NEW" },
                    files: [],
                    logoUrl: null,
                    logoScale: 1.0,
                    pageNumberPos: 'right',
                    lastModified: new Date().toISOString(),
                    createdBy: uid
                };
                try {
                    const colRef = collection(db, "artifacts", appId, "public", "data", "projects");
                    const docRef = await addDoc(colRef, newProject);
                    setActiveProjectId(docRef.id);
                } catch(e) { console.error("Create project failed", e); }
            };

            // NEW: COPY PROJECT
            const handleCopyProject = async (e, projectId) => {
                e.stopPropagation();
                if (isOfflineMode) { alert("Copy unavailable in offline mode"); return; }
                
                setIsProcessing(true);
                try {
                    // 1. Get Source
                    const sourceRef = doc(db, "artifacts", appId, "public", "data", "projects", projectId);
                    const sourceSnap = await getDoc(sourceRef);
                    
                    if (!sourceSnap.exists()) throw new Error("Source project not found");
                    const sourceData = sourceSnap.data();

                    // 2. Prepare New Data
                    const newMeta = { 
                        ...sourceData.projectMeta, 
                        title: `${sourceData.projectMeta.title} (Copy)`,
                        number: `${sourceData.projectMeta.number}-CPY`
                    };

                    // 3. Deep Copy Files (Assign new IDs to list items, keep Storage refs)
                    const newFiles = (sourceData.files || []).map(f => ({
                        ...f,
                        id: crypto.randomUUID() // Critical: New List ID so keys don't conflict
                    }));

                    const newProject = {
                        ...sourceData,
                        projectMeta: newMeta,
                        files: newFiles,
                        lastModified: new Date().toISOString(),
                        createdBy: user.uid,
                        originalProjectId: projectId // Traceability
                    };

                    // 4. Save
                    const colRef = collection(db, "artifacts", appId, "public", "data", "projects");
                    const docRef = await addDoc(colRef, newProject);
                    
                    setActiveProjectId(docRef.id);
                } catch (err) {
                    console.error("Copy failed", err);
                    alert("Failed to copy project: " + err.message);
                } finally {
                    setIsProcessing(false);
                }
            };

            const handleDeleteProject = async (projectId, e) => {
                e.stopPropagation();
                if (!confirm("Delete project? Files in cloud storage will REMAIN to protect Shared/Copied projects.")) return;
                
                if (isOfflineMode) { return; }

                const projectToDelete = projects.find(p => p.id === projectId);
                if (!projectToDelete) return;

                try {
                    // NOTE: Auto-delete of cloud files is DISABLED to support Copy/Clone functionality safely.
                    // If we delete the PDF blob, all copied projects referencing it will break.
                    
                    await deleteDoc(doc(db, "artifacts", appId, "public", "data", "projects", projectId));
                    
                    if (projectId === activeProjectId) {
                        const remaining = projects.filter(p => p.id !== projectId);
                        setActiveProjectId(remaining.length > 0 ? remaining[0].id : null);
                    }
                } catch(e) { console.error("Delete failed", e); }
            };

            // --- Handlers ---

            const uploadFileToFirebase = async (file) => {
                if (isOfflineMode || !user) return null;
                // Path Rule compliance: /artifacts/{appId}/public/data/files
                const storagePath = `artifacts/${appId}/public/data/files/${crypto.randomUUID()}-${file.name}`;
                const fileRef = ref(storage, storagePath);
                await uploadBytes(fileRef, file);
                setRefreshStats(prev => prev + 1); 
                const url = await getDownloadURL(fileRef);
                return { url, path: storagePath };
            };

            const deleteFromCloud = async (url) => {
                if (isOfflineMode || !user || !url) return;
                try {
                    if (url.includes('firebasestorage.googleapis.com')) {
                        const fileRef = ref(storage, url);
                        await deleteObject(fileRef);
                        setRefreshStats(prev => prev + 1);
                    }
                } catch (e) { console.warn("Cloud deletion failed", e); }
            };

            // Refactored Upload Logic to support both Input Change and Drag & Drop
            const processFiles = async (fileList) => {
                const uploadedFiles = Array.from(fileList);
                const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                
                if (!isOfflineMode) setSyncStatus('syncing');

                for (const file of uploadedFiles) {
                    // --- VALIDATION: Only allow PDFs ---
                    if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {
                        console.warn(`Skipping non-PDF file: ${file.name}`);
                        continue;
                    }

                    let pageCount = 'Calc...', rawPages = 0;
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await window.PDFLib.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                        rawPages = pdf.getPageCount();
                        pageCount = rawPages;
                    } catch (err) { pageCount = 'Err'; }

                    let downloadInfo = { url: null, path: null };
                    if (!isOfflineMode && user) {
                        try { downloadInfo = await uploadFileToFirebase(file); } catch (err) { console.warn("Upload failed"); }
                    }

                    setFiles(prev => [...prev, {
                        id: crypto.randomUUID(),
                        name: file.name,
                        downloadURL: downloadInfo.url,
                        storagePath: downloadInfo.path, 
                        fileObj: file, 
                        sectionTitle: file.name.replace('.pdf', '').replace(/_/g, ' '), 
                        sectionSubtitle: '',
                        calcsBy: '', checkedBy: '', revision: '0', uploadDate: currentDate,
                        pageCount, rawPages,
                        size: (file.size / 1024 / 1024).toFixed(2) + ' MB',
                        depth: 0, isPlaceholder: false,
                        objective: "",
                        program: ""
                    }]);
                }
                if (!isOfflineMode) setSyncStatus('synced');
            };

            const handleFileUpload = (e) => {
                if (e.target.files && e.target.files.length > 0) {
                    processFiles(e.target.files);
                }
            };

            // --- GLOBAL DROP HANDLERS ---
            const handleGlobalDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Check if items are being dragged (files)
                if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
                     // Basic check if it's likely a file drag
                     setIsDraggingFile(true);
                }
            };

            const handleGlobalDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDraggingFile(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    processFiles(e.dataTransfer.files);
                }
            };
            
             // Reset drag state if drag leaves window
             const handleGlobalDragLeave = (e) => {
                // Only if leaving the document
                if (e.relatedTarget === null) {
                    setIsDraggingFile(false);
                }
             }


            const handleZoneDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
            };

            const handleZoneDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDraggingFile(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    processFiles(e.dataTransfer.files);
                }
            };

            const handleLogoUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (file.size > 500 * 1024) { 
                    alert("Logo is too large. Please use a file smaller than 500KB.");
                    return;
                }
                
                const reader = new FileReader();
                reader.onloadend = () => {
                    const base64 = reader.result;
                    setLogoUrl(base64); 
                };
                reader.readAsDataURL(file);
            };

            const handleReplaceFile = async (e, id) => {
                const file = e.target.files[0];
                if (!file) return;
                const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                if (syncStatus !== 'offline') setSyncStatus('syncing');

                let pageCount = 0;
                try {
                    const ab = await file.arrayBuffer();
                    const pdf = await window.PDFLib.PDFDocument.load(ab, { ignoreEncryption: true });
                    pageCount = pdf.getPageCount();
                } catch(err) { console.error(err); }

                const oldFile = files.find(f => f.id === id);
                const oldUrl = oldFile ? oldFile.downloadURL : null;

                let downloadInfo = { url: null, path: null };
                if (!isOfflineMode && user) {
                    try { downloadInfo = await uploadFileToFirebase(file); } catch(e) {}
                }

                // NOTE: We do NOT delete the old file here anymore to be safe with copies.
                // if (downloadInfo.url && oldUrl) await deleteFromCloud(oldUrl);

                setFiles(prev => prev.map(f => {
                    if (f.id !== id) return f;
                    return {
                        ...f,
                        name: file.name,
                        downloadURL: downloadInfo.url,
                        storagePath: downloadInfo.path,
                        fileObj: file,
                        uploadDate: currentDate,
                        size: (file.size / 1024 / 1024).toFixed(2) + ' MB',
                        pageCount, rawPages: pageCount
                    };
                }));
                if (!isOfflineMode) setSyncStatus('synced');
            };

            const handleAddPlaceholder = () => {
                const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                setFiles(prev => [...prev, {
                    id: crypto.randomUUID(), downloadURL: null, fileObj: null,
                    name: "Placeholder Section", sectionTitle: "New Placeholder", sectionSubtitle: "",
                    calcsBy: "", checkedBy: "", revision: "0", uploadDate: currentDate, pageCount: 5, rawPages: 5, size: "N/A", depth: 0, isPlaceholder: true,
                    objective: "", program: ""
                }]);
            };
            
            // --- NEW: Handle Adding Section Header ---
            const handleAddHeader = () => {
                const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                setFiles(prev => [...prev, {
                    id: crypto.randomUUID(), downloadURL: null, fileObj: null,
                    name: "Section Header", sectionTitle: "New Section", sectionSubtitle: "",
                    calcsBy: "", checkedBy: "", revision: "0", uploadDate: currentDate, pageCount: 0, rawPages: 0, size: "N/A", depth: 0, 
                    isHeader: true, // Distinct flag
                    objective: "", program: ""
                }]);
            };

            const handleReplacePlaceholder = async (e, id) => {
                const file = e.target.files[0];
                if(!file) return;
                handleReplaceFile(e, id); 
                setFiles(prev => prev.map(f => f.id === id ? { ...f, isPlaceholder: false } : f));
            };
            
            const removeFile = async (id) => {
                // Modified: Only remove from LIST state. 
                // Do NOT delete from Cloud Storage, as other projects might reference this file (Copy).
                setFiles(files.filter(f => f.id !== id));
            };
            
            const removeLogo = () => { setLogoUrl(null); if (logoInputRef.current) logoInputRef.current.value = ""; };
            const updateFileField = (id, field, value) => setFiles(files.map(f => f.id === id ? { ...f, [field]: value } : f));
            const updateMeta = (field, value) => setProjectMeta(prev => ({ ...prev, [field]: value }));
            const updatePlaceholderPages = (id, val) => {
                const count = parseInt(val) || 1;
                setFiles(prev => prev.map(f => f.id === id ? { ...f, pageCount: count, rawPages: count } : f));
            };
            const moveFile = (index, direction) => {
                if ((direction === -1 && index === 0) || (direction === 1 && index === files.length - 1)) return;
                const newFiles = [...files];
                const temp = newFiles[index];
                newFiles[index] = newFiles[index + direction];
                newFiles[index + direction] = temp;
                if (index + direction === 0) newFiles[index + direction].depth = 0;
                setFiles(newFiles);
            };
            const changeDepth = (index, delta) => {
                const newFiles = [...files];
                const newDepth = newFiles[index].depth + delta;
                if (newDepth >= 0 && newDepth <= 2 && !(index === 0 && newDepth > 0)) {
                    newFiles[index].depth = newDepth;
                    setFiles(newFiles);
                }
            };
            
            const handleLogout = () => {
                localStorage.removeItem('calcBinder_firebaseConfig');
                window.location.reload();
            };
            
            const handleUpdateFileDetails = (fileId, newDetails) => {
                setFiles(prev => prev.map(f => f.id === fileId ? { ...f, ...newDetails } : f));
            };

            // --- DRAG HANDLERS ---
            const handleDragStart = (e, index) => {
                setDragItem({ index, x: e.clientX });
                e.dataTransfer.effectAllowed = "move";
                // Optional: set custom drag image
            };

            const handleDragEnter = (e, index) => {
                setDragOverIndex(index);
            };

            const handleDragOver = (e) => {
                e.preventDefault(); // Necessary to allow dropping
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDragEnd = () => {
                setDragItem(null);
                setDragOverIndex(null);
            };

            const handleDrop = (e, index) => {
                e.preventDefault();
                e.stopPropagation(); // CRITICAL: Stop bubbling to global drop handler
                
                // --- FIX: Check if dragging external files first! ---
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    processFiles(e.dataTransfer.files);
                    return;
                }

                if (dragItem === null) return;
                
                const dragIndex = dragItem.index;
                const dropIndex = index;
                
                if (dragIndex === dropIndex) {
                    // Check for indent only
                    const deltaX = e.clientX - dragItem.x;
                    const indentChange = Math.round(deltaX / 40); // 40px threshold
                    if (indentChange !== 0) changeDepth(dragIndex, indentChange);
                    return;
                }

                // Move logic
                const newFiles = [...files];
                const [movedItem] = newFiles.splice(dragIndex, 1);
                
                // Calculate indent change
                const deltaX = e.clientX - dragItem.x;
                const indentChange = Math.round(deltaX / 40); 
                
                let newDepth = movedItem.depth + indentChange;
                newDepth = Math.max(0, Math.min(2, newDepth)); // Clamp 0-2
                movedItem.depth = newDepth;

                newFiles.splice(dropIndex, 0, movedItem);
                setFiles(newFiles);
            };

            const numberedFiles = useMemo(() => {
                let main = 0, sub = 0, subSub = 0;
                return files.map(file => {
                    let label = "";
                    if (file.depth === 0) { main++; sub = 0; subSub = 0; label = `${main}`; } 
                    else if (file.depth === 1) { sub++; subSub = 0; label = `${main}.${sub}`; } 
                    else if (file.depth === 2) { subSub++; label = `${main}.${sub}.${subSub}`; }
                    return { ...file, sectionLabel: label };
                });
            }, [files]);

            // --- HELPER: Measure Wrapped Text Height ---
            const measureWrappedTextHeight = (text, size, font, maxWidth) => {
                if (!text) return 0;
                const words = String(text).split(' ');
                let lines = [], currentLine = words[0];
                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = font.widthOfTextAtSize(`${currentLine} ${word}`, size);
                    if (width < maxWidth) currentLine += ` ${word}`;
                    else { lines.push(currentLine); currentLine = word; }
                }
                lines.push(currentLine);
                return lines.length * (size * 1.3);
            };

            // --- HELPER: Get Wrapped Lines Array ---
            const getWrappedLines = (text, size, font, maxWidth) => {
                if (!text) return [];
                const words = String(text).split(' ');
                let lines = [], currentLine = words[0];
                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = font.widthOfTextAtSize(`${currentLine} ${word}`, size);
                    if (width < maxWidth) {
                        currentLine += ` ${word}`;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
                return lines;
            };

            // Enhanced cleaner to replace newlines with spaces for safety
            const cleanText = (text) => {
                if (!text) return "";
                return String(text)
                    .replace(/[\r\n]+/g, " ") // Replace newlines with spaces
                    .replace(/[\u2018\u2019]/g, "'") // Smart quotes
                    .replace(/[\u201C\u201D]/g, '"') // Smart double quotes
                    .replace(/[\u2013\u2014]/g, '-') // Dashes
                    .replace(/[\u2022]/g, '-')       // Bullets
                    .replace(/[^\x00-\x7F]/g, "");   // Strip non-ASCII
            };

            const drawWrappedText = (page, text, y, size, font, rgb, color = [0,0,0], maxWidth, align = 'center') => {
                if (!text) return;
                const safeText = cleanText(text);
                const { width } = page.getSize();
                const safeWidth = maxWidth || (width - 100);
                const lines = getWrappedLines(safeText, size, font, safeWidth);
                const lineHeight = size * 1.3;
                const centerIndex = (lines.length - 1) / 2;
                lines.forEach((line, i) => {
                    const dy = (centerIndex - i) * lineHeight;
                    const lineY = y + dy;
                    const textWidth = font.widthOfTextAtSize(line, size);
                    let xPos = (width - textWidth) / 2;
                    if (align === 'left') xPos = 50;
                    page.drawText(line, { x: xPos, y: lineY, size: size, font: font, color: rgb(...color) });
                });
            };

            // --- FORMAL DIVIDER GENERATION ---
            const drawFormalDivider = (page, fileData, projectMeta, embeddedLogo, fonts, rgb) => {
                // Safety check wrapper
                try {
                    const { width, height } = page.getSize();
                    const { fontBold, fontRegular } = fonts;
                    const margin = 40;
                    const contentWidth = width - (margin * 2);
                    
                    // Header Grid (Project Info)
                    const headerH = 80;
                    const headerY = height - margin - headerH;
                    page.drawLine({ start: { x: margin, y: headerY }, end: { x: width - margin, y: headerY }, thickness: 1, color: rgb(0,0,0) });

                    // Project Title (Top Left)
                    page.drawText("PROJECT:", { x: margin + 10, y: height - margin - 20, size: 8, font: fontBold, color: rgb(0.5,0.5,0.5) });
                    drawWrappedText(page, projectMeta.title, height - margin - 55, 14, fontBold, rgb, [0,0,0], contentWidth - 200, 'left');

                    // Logo placement
                    if (embeddedLogo) {
                        const logoH = 40;
                        const scale = logoH / embeddedLogo.height;
                        const logoW = embeddedLogo.width * scale;
                        page.drawImage(embeddedLogo, { x: width - margin - logoW - 10, y: height - margin - 10 - logoH, width: logoW, height: logoH });
                    }

                    // Section Info Block
                    const titleY = headerY - 60;
                    drawWrappedText(page, `SECTION ${fileData.sectionLabel}`, titleY, 24, fontBold, rgb, [0,0,0]);
                    drawWrappedText(page, fileData.sectionTitle || "Untitled Section", titleY - 40, 18, fontBold, rgb, [0,0,0]);
                    if (fileData.sectionSubtitle) {
                        drawWrappedText(page, fileData.sectionSubtitle, titleY - 70, 14, fontRegular, rgb, [0.3,0.3,0.3]);
                    }

                    // Body Content (Grid simulation)
                    const bodyStart = titleY - 120;
                    let cursorY = bodyStart;

                    // Helper to draw labelled block
                    const drawBlock = (label, text) => {
                        if (!text) return;
                        // Safety check: stop drawing if we hit the footer
                        if (cursorY < (margin + 65 + 40)) return; 

                        page.drawText(label, { x: margin + 20, y: cursorY, size: 9, font: fontBold, color: rgb(0.5,0.5,0.5) });
                        const safeText = cleanText(text);
                        const lines = getWrappedLines(safeText, 10, fontRegular, contentWidth - 40);
                        
                        lines.forEach((line, i) => {
                            const lineY = cursorY - 15 - (i*12);
                            if (lineY > (margin + 65 + 10)) { // Ensure line doesn't overlap footer
                                page.drawText(line, { x: margin + 20, y: lineY, size: 10, font: fontRegular, color: rgb(0,0,0) });
                            }
                        });
                        cursorY -= (lines.length * 12) + 35; 
                    };

                    // DYNAMIC FIELDS RENDER
                    // Use custom fields if available, otherwise fallback to defaults (Objective/Program)
                    const fieldsToDraw = fileData.customFields || [
                        { label: "OBJECTIVE / SCOPE", value: fileData.objective, isVisible: !!fileData.objective },
                        { label: "COMPUTER PROGRAM", value: fileData.program, isVisible: !!fileData.program }
                    ];

                    fieldsToDraw.forEach(field => {
                        // Added safe navigation for field.label
                        if (field.isVisible && field.value && field.label) {
                            drawBlock(field.label.toUpperCase() + ":", field.value);
                        }
                    });

                    // Footer Sign-off (Standard Engineering Block)
                    // --- CONDITION: Only if not a Header ---
                    if (!fileData.isHeader) {
                        const boxBottom = margin;
                        const boxHeight = 65;
                        const boxTop = boxBottom + boxHeight;

                        // Outer Box
                        page.drawRectangle({
                            x: margin,
                            y: boxBottom,
                            width: contentWidth,
                            height: boxHeight,
                            borderColor: rgb(0, 0, 0),
                            borderWidth: 1,
                        });

                        // --- CHANGED TO 3 COLUMNS ---
                        const colCount = 3;
                        const colW = contentWidth / colCount;

                        // Vertical Separators & Text
                        for (let i = 0; i < colCount; i++) {
                            // Line (except first)
                            if (i > 0) {
                                const lineX = margin + (i * colW);
                                page.drawLine({
                                    start: { x: lineX, y: boxBottom },
                                    end: { x: lineX, y: boxTop },
                                    thickness: 1,
                                    color: rgb(0, 0, 0)
                                });
                            }
                        }
                        
                        const drawFooterCell = (index, label, name, date) => {
                            const cellX = margin + (index * colW) + 4; // padding
                            // Label (Top Left of cell)
                            page.drawText(label, { x: cellX, y: boxTop - 12, size: 6, font: fontBold, color: rgb(0.5, 0.5, 0.5) });
                            // Name (Center-ish)
                            if (name) page.drawText(name, { x: cellX, y: boxTop - 30, size: 9, font: fontRegular, color: rgb(0, 0, 0) });
                            // Date (Bottom)
                            if (date) page.drawText(date, { x: cellX, y: boxBottom + 8, size: 7, font: fontRegular, color: rgb(0.3, 0.3, 0.3) });
                        };

                        drawFooterCell(0, "DESIGNED BY", fileData.designedBy, fileData.designedDate);
                        drawFooterCell(1, "CHECKED BY", fileData.checkedBy, fileData.checkedDate);
                        // --- CONSOLIDATED FIELD ---
                        drawFooterCell(2, "QC REVIEW BY", fileData.qcReviewBy, fileData.qcReviewDate); 
                        
                        if (fileData.revision) {
                            page.drawText(`REV: ${fileData.revision}`, { x: width - margin - 150, y: titleY + 30, size: 10, font: fontBold, color: rgb(0,0,0) });
                        }
                    }
                } catch(err) {
                    console.error("Error drawing divider page:", err);
                    page.drawText("Error generating divider content", { x: 50, y: 50, size: 12, color: rgb(1, 0, 0) });
                }
            };


            const generateBinder = async (action = 'download', isAuto = false) => {
                if (!isAuto) setIsProcessing(true); // Only show loading spinner for manual clicks
                try {
                    const { PDFDocument, StandardFonts, rgb } = window.PDFLib;
                    const mergedPdf = await PDFDocument.create();
                    const fontBold = await mergedPdf.embedFont(StandardFonts.HelveticaBold);
                    const fontRegular = await mergedPdf.embedFont(StandardFonts.Helvetica);
                    const fontOblique = await mergedPdf.embedFont(StandardFonts.HelveticaOblique);
                    const fonts = { fontBold, fontRegular, fontOblique };

                    // Logo Fetch
                    let embeddedLogo = null;
                    if (logoUrl) { try { const res = await fetch(logoUrl); const logoBytes = await res.arrayBuffer(); const isPng = logoUrl.startsWith('data:image/png'); embeddedLogo = isPng ? await mergedPdf.embedPng(logoBytes) : await mergedPdf.embedJpg(logoBytes); } catch(e){} }

                    // --- GENERATE PAGES ---
                    const LETTER_SIZE = [612, 792];
                    const coverPage = mergedPdf.addPage(LETTER_SIZE);
                    const { width, height } = coverPage.getSize();
                    if (embeddedLogo) { const s = 40/embeddedLogo.height; const w = embeddedLogo.width*s; coverPage.drawImage(embeddedLogo, { x: (width-w)/2, y: height-140, width: w, height: 40 }); }
                    drawWrappedText(coverPage, projectMeta.title.toUpperCase(), height - 250, 24, fontBold, rgb, [0,0,0], width - 100);
                    drawWrappedText(coverPage, `PROJECT NO: ${projectMeta.number}`, height - 300, 14, fontRegular, rgb, [0.4,0.4,0.4], width - 100);
                    drawWrappedText(coverPage, (projectMeta.docType || "CALCULATION PACKAGE").toUpperCase(), height / 2, 18, fontBold, rgb, [0,0,0], width - 100);
                    drawWrappedText(coverPage, projectMeta.client, height - 570, 16, fontRegular, rgb, [0,0,0], width - 100);
                    drawWrappedText(coverPage, projectMeta.date, height - 640, 14, fontRegular, rgb, [0,0,0], width - 100);
                    if (projectMeta.description) drawWrappedText(coverPage, projectMeta.description, 100, 10, fontOblique, rgb, [0.3,0.3,0.3], width - 150);

                    // --- TOC ---
                    const fileAnalysis = [];
                    const entriesPerPage = 25; 
                    const tocPageCount = Math.ceil(numberedFiles.length / entriesPerPage) || 1;
                    let runningPageNumber = 1 + tocPageCount + 1; 
                    for (const f of numberedFiles) {
                        const pCount = f.rawPages || 1; 
                        fileAnalysis.push({ ...f, startPage: runningPageNumber + 1 });
                        // Header pages (dividers) still count as a page in numbering logic if we include them
                        runningPageNumber += f.isHeader ? 1 : (1 + pCount);
                    }

                    for (let p = 0; p < tocPageCount; p++) {
                        const tocPage = mergedPdf.addPage(LETTER_SIZE);
                        drawWrappedText(tocPage, "TABLE OF CONTENTS", height - 60, 24, fontBold, rgb, [0,0,0]);
                        const startIdx = p * entriesPerPage;
                        const endIdx = Math.min(startIdx + entriesPerPage, fileAnalysis.length);
                        let yPos = height - 120;
                        for (let i = startIdx; i < endIdx; i++) {
                            const item = fileAnalysis[i];
                            const indent = item.depth === 0 ? 50 : item.depth === 1 ? 70 : 90;
                            const font = item.depth === 0 ? fontBold : fontRegular;
                            const fontSize = item.depth === 0 ? 12 : 11;
                            const maxWidth = width - (indent + 60) - 80;
                            const title = item.sectionTitle || "Untitled";
                            
                            tocPage.drawText(item.sectionLabel, { x: indent, y: yPos, size: fontSize, font });
                            
                            const lines = getWrappedLines(title, fontSize, font, maxWidth);
                            lines.forEach((line, lx) => {
                                tocPage.drawText(line, { x: indent + 60, y: yPos - (lx*14), size: fontSize, font });
                            });
                            
                            const pageNumStr = item.startPage.toString();
                            tocPage.drawText(pageNumStr, { x: width - 50 - font.widthOfTextAtSize(pageNumStr, fontSize), y: yPos, size: fontSize, font });
                            
                            const entryHeight = (lines.length * 14) + 10;
                            yPos -= entryHeight;
                        }
                    }

                    // --- SECTIONS ---
                    
                    for (const f of numberedFiles) {
                        const divPage = mergedPdf.addPage(LETTER_SIZE);
                        drawFormalDivider(divPage, f, projectMeta, embeddedLogo, fonts, rgb);
                        
                        if (!f.isHeader) {
                            if (f.isPlaceholder) {
                                for(let k=0; k < (f.rawPages||1); k++) {
                                    const p = mergedPdf.addPage(LETTER_SIZE);
                                    drawWrappedText(p, "PLACEHOLDER", height/2, 20, fontBold, rgb, [0.8,0.8,0.8]);
                                }
                            } else {
                                try {
                                    let bytes;
                                    if (f.fileObj) bytes = await f.fileObj.arrayBuffer();
                                    else if (f.downloadURL) { 
                                        const r = await fetch(f.downloadURL); 
                                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                                        bytes = await r.arrayBuffer(); 
                                    }
                                    if (bytes) {
                                        const src = await PDFDocument.load(bytes, { ignoreEncryption: true });
                                        (await mergedPdf.copyPages(src, src.getPageIndices())).forEach(p => mergedPdf.addPage(p));
                                    }
                                } catch(e) {
                                    const errP = mergedPdf.addPage(LETTER_SIZE);
                                    errP.drawText("Error loading file content", { x: 50, y: 700 });
                                }
                            }
                        }
                    }
                    
                    // --- BOOKMARKS REMOVED ---

                    // Page Numbers
                    const count = mergedPdf.getPageCount();
                    for (let i = 0; i < count; i++) {
                         const p = mergedPdf.getPage(i);
                         const txt = `${i+1}`;
                         const tw = fontRegular.widthOfTextAtSize(txt, 10);
                         let x = pageNumberPos === 'left' ? 50 : pageNumberPos === 'center' ? (width - tw)/2 : width - 50 - tw;
                         p.drawText(txt, { x, y: 30, size: 10, font: fontRegular });
                    }

                    const pdfBytes = await mergedPdf.save();
                    // const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    // const url = URL.createObjectURL(blob);
                    
                    if (action === 'preview') {
                        setPdfData(pdfBytes);
                    } else if (action === 'open') {
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.target = '_blank';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    } else {
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `Binder_${projectMeta.number}.pdf`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }

                } catch (e) { alert("Error: " + e.message); } finally { setIsProcessing(false); }
            };

            return (
                <div className="h-full flex flex-col" onDragOver={handleGlobalDragOver} onDrop={handleGlobalDrop} onDragLeave={handleGlobalDragLeave}>
                    {editingFile && <CoverSheetModal key={editingFile.id} file={editingFile} projectMeta={projectMeta} onClose={() => setEditingFile(null)} onSave={handleUpdateFileDetails} />}
                    {showCorsHelp && <CorsHelpModal onClose={() => setShowCorsHelp(false)} />}
                    {showConfigModal && <OutputConfigModal onClose={() => setShowConfigModal(false)} pageNumberPos={pageNumberPos} setPageNumberPos={setPageNumberPos} totalFiles={files.length} />}

                    {/* Header */}
                    <div className="flex-none bg-white border-b border-slate-200 px-6 py-4 flex justify-between items-center shadow-sm z-10">
                        <div>
                            <h1 className="text-xl font-bold text-slate-800 flex items-center gap-2"><FilePlus className="w-6 h-6 text-blue-600" /> CalcBinder <span className="text-slate-400 font-light text-sm">Cloud</span></h1>
                            <p className="text-xs text-slate-500">Structural Engineering Calculation Compiler</p>
                        </div>
                        <div className="flex items-center gap-3">
                            {authError && <div className="text-xs text-red-600 bg-red-50 px-2 py-1 rounded flex items-center gap-1"><AlertTriangle className="w-3 h-3" />{authError}</div>}
                            
                            <div className="flex items-center gap-2 mr-2 bg-slate-100 px-2 py-1 rounded-md">
                                <span className="text-xs font-semibold text-slate-500">Live:</span>
                                <button 
                                    onClick={() => setAutoUpdate(!autoUpdate)} 
                                    className={`relative w-8 h-4 rounded-full transition-colors ${autoUpdate ? 'bg-green-500' : 'bg-slate-300'}`}
                                >
                                    <div className={`absolute top-0.5 left-0.5 w-3 h-3 bg-white rounded-full shadow transition-transform ${autoUpdate ? 'translate-x-4' : 'translate-x-0'}`} />
                                </button>
                            </div>

                            <button onClick={() => setShowConfigModal(true)} className="p-2 text-slate-500 hover:bg-slate-100 rounded-full transition-colors" title="Output Settings"><Settings className="w-5 h-5" /></button>
                            <button onClick={() => generateBinder('preview')} disabled={isProcessing} className="flex items-center gap-2 px-4 py-2 bg-white border border-slate-300 text-slate-700 font-medium rounded-md hover:bg-slate-50 transition-colors">{isProcessing ? <Loader2 className="w-4 h-4 animate-spin" /> : <RefreshCw className="w-4 h-4" />} Update</button>
                            <button onClick={() => generateBinder('download')} disabled={isProcessing} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white font-medium rounded-md hover:bg-blue-700 transition-colors shadow-sm"><Save className="w-4 h-4" /> Download PDF</button>
                        </div>
                    </div>

                    {/* Main Layout */}
                    <div className="flex-1 grid grid-cols-12 overflow-hidden">
                        
                        {/* 1. Projects Sidebar (16%) */}
                        <div className="col-span-2 bg-white border-r border-slate-200 flex flex-col h-full overflow-hidden">
                            <div className="p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50">
                                <h2 className="font-semibold text-slate-700 text-sm flex items-center gap-2"><Layout className="w-4 h-4" /> Projects</h2>
                                <button onClick={() => handleCreateProject(user?.uid)} className="p-1 hover:bg-white rounded shadow-sm text-blue-600"><FolderPlus className="w-4 h-4" /></button>
                            </div>
                            <div className="overflow-y-auto flex-1 p-2 space-y-1">
                                {projects.map(p => (
                                    <div key={p.id} onClick={() => setActiveProjectId(p.id)} className={`p-2 rounded text-xs cursor-pointer flex justify-between group ${activeProjectId === p.id ? 'bg-blue-50 text-blue-700 font-medium border-l-4 border-blue-500' : 'hover:bg-slate-50 text-slate-600 border-l-4 border-transparent'}`}>
                                        <div className="truncate pr-1">
                                            <div className="truncate">{p.id === activeProjectId ? projectMeta.title : (p.projectMeta?.title || "Untitled")}</div>
                                            <div className="text-[10px] opacity-70">{new Date(p.lastModified).toLocaleDateString()}</div>
                                        </div>
                                        <div className="flex flex-col gap-1 opacity-0 group-hover:opacity-100">
                                            <button onClick={(e) => handleCopyProject(e, p.id)}><Copy className="w-3 h-3 hover:text-blue-500" /></button>
                                            <button onClick={(e) => handleDeleteProject(p.id, e)}><Trash2 className="w-3 h-3 hover:text-red-500" /></button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                            <div className="p-3 border-t border-slate-200 bg-slate-50">
                                <button onClick={handleLogout} className="w-full py-1.5 text-xs text-slate-500 hover:text-red-600 hover:bg-white border border-transparent hover:border-slate-200 rounded transition-colors flex items-center justify-center gap-2"><LogOut className="w-3 h-3" /> Disconnect</button>
                            </div>
                        </div>

                        {/* 2. Main Workspace (50%) */}
                        <div className="col-span-6 bg-slate-50 h-full overflow-y-auto p-6 border-r border-slate-200">
                            {/* Metadata Card */}
                            <div className="bg-white p-5 rounded-lg shadow-sm border border-slate-200 mb-6">
                                <div className="grid grid-cols-12 gap-4">
                                    {/* Logo */}
                                    <div className="col-span-3">
                                        <div className="w-full aspect-square bg-slate-50 border-2 border-dashed border-slate-300 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:border-blue-400 relative group" onClick={() => logoInputRef.current?.click()}>
                                            {logoUrl ? <><img src={logoUrl} className="w-full h-full object-contain p-2" /><button onClick={(e)=>{e.stopPropagation();removeLogo();}} className="absolute top-1 right-1 p-1 bg-white rounded-full shadow hover:text-red-500 opacity-0 group-hover:opacity-100"><X className="w-3 h-3" /></button></> : <ImageIcon className="w-6 h-6 text-slate-300" />}
                                            <input type="file" className="hidden" ref={logoInputRef} onChange={handleLogoUpload} />
                                        </div>
                                        <div className="mt-2 flex justify-center items-center gap-1"><span className="text-[9px] font-bold text-slate-400 uppercase">Scale</span><input type="number" step="0.1" value={logoScale} onChange={e=>setLogoScale(e.target.value)} className="w-10 text-xs border rounded text-center" /></div>
                                    </div>
                                    {/* Fields */}
                                    <div className="col-span-9 grid grid-cols-2 gap-3">
                                        <div className="col-span-2"><label className="block text-[10px] font-bold text-slate-400 uppercase">Project Name</label><input type="text" value={projectMeta.title} onChange={e => updateMeta('title', e.target.value)} className="w-full px-2 py-1 text-sm border border-slate-300 rounded focus:border-blue-500 outline-none" /></div>
                                        <div><label className="block text-[10px] font-bold text-slate-400 uppercase">Number</label><input type="text" value={projectMeta.number} onChange={e => updateMeta('number', e.target.value)} className="w-full px-2 py-1 text-sm border border-slate-300 rounded outline-none" /></div>
                                        <div><label className="block text-[10px] font-bold text-slate-400 uppercase">Date</label><input type="date" value={projectMeta.date} onChange={e => updateMeta('date', e.target.value)} className="w-full px-2 py-1 text-sm border border-slate-300 rounded outline-none" /></div>
                                        <div className="col-span-2"><label className="block text-[10px] font-bold text-slate-400 uppercase">Client</label><input type="text" value={projectMeta.client} onChange={e => updateMeta('client', e.target.value)} className="w-full px-2 py-1 text-sm border border-slate-300 rounded outline-none" /></div>
                                    </div>
                                </div>
                            </div>

                            {/* Drop Zones */}
                            <div className="flex gap-3 mb-6">
                                <div className={`flex-1 border-2 border-dashed rounded-lg p-4 text-center transition-colors cursor-pointer ${isDraggingFile ? 'border-blue-500 bg-blue-50' : 'border-slate-300 bg-white hover:border-blue-400'}`} onClick={() => fileInputRef.current?.click()} onDragOver={handleZoneDragOver} onDrop={handleZoneDrop}>
                                    <input type="file" multiple accept=".pdf" className="hidden" ref={fileInputRef} onChange={handleFileUpload} />
                                    <Upload className={`w-8 h-8 mx-auto mb-2 ${isDraggingFile ? 'text-blue-500' : 'text-slate-400'}`} />
                                    <p className="text-sm font-medium text-slate-600">Add PDFs</p>
                                </div>
                                <div className="flex flex-col gap-2 w-40">
                                    <button onClick={handleAddPlaceholder} className="flex-1 border border-slate-200 bg-white hover:bg-emerald-50 hover:border-emerald-300 rounded-lg flex items-center justify-center gap-2 text-xs font-medium text-slate-600 transition-colors"><FileQuestion className="w-4 h-4 text-emerald-500" /> Placeholder</button>
                                    <button onClick={handleAddHeader} className="flex-1 border border-slate-200 bg-white hover:bg-violet-50 hover:border-violet-300 rounded-lg flex items-center justify-center gap-2 text-xs font-medium text-slate-600 transition-colors"><Type className="w-4 h-4 text-violet-500" /> Header</button>
                                </div>
                            </div>

                            {/* File List */}
                            <ul className="space-y-2">
                                {numberedFiles.map((file, index) => (
                                    <li 
                                        key={file.id} 
                                        className={`bg-white p-3 rounded border shadow-sm flex gap-3 transition-all ${file.isHeader ? 'border-l-4 border-l-violet-400 bg-violet-50/30' : (file.isPlaceholder ? 'bg-yellow-50 border-l-4 border-l-yellow-400' : 'border-slate-200')} ${dragOverIndex===index ? 'border-t-2 border-t-blue-500':''} ${dragItem?.index===index ? 'opacity-40':''}`}
                                        // IMPORTANT: Remove draggable from here to allow text selection
                                        onDragEnter={(e) => handleDragEnter(e, index)}
                                        onDragOver={handleDragOver}
                                        onDragEnd={handleDragEnd}
                                        onDrop={(e) => handleDrop(e, index)}
                                    >
                                        {/* Drag Handle - ONLY this is draggable */}
                                        <div 
                                            className="cursor-move p-2 text-slate-300 hover:text-slate-500 rounded hover:bg-slate-200 self-center mr-2" 
                                            title="Drag to reorder"
                                            draggable
                                            onDragStart={(e) => {
                                                // Optional: Set drag image to the whole row
                                                if (e.dataTransfer.setDragImage) {
                                                     const row = e.currentTarget.closest('li');
                                                     if (row) e.dataTransfer.setDragImage(row, 0, 0);
                                                }
                                                handleDragStart(e, index);
                                            }}
                                            onDragEnd={handleDragEnd} // Need to attach drag end here too
                                        >
                                            <GripVertical className="w-5 h-5" />
                                        </div>

                                        {/* Arrow Controls (Restored) */}
                                        <div className="flex flex-col items-center justify-center gap-2 mr-2">
                                            <div className="flex flex-col">
                                                <button onClick={() => moveFile(index, -1)} disabled={index===0} className="text-slate-300 hover:text-slate-600 disabled:opacity-0"><ArrowUp className="w-3 h-3" /></button>
                                                <button onClick={() => moveFile(index, 1)} disabled={index===files.length-1} className="text-slate-300 hover:text-slate-600 disabled:opacity-0"><ArrowDown className="w-3 h-3" /></button>
                                            </div>
                                            <div className="flex gap-1">
                                                <button onClick={() => changeDepth(index, -1)} disabled={file.depth===0} className="text-slate-300 hover:text-slate-600 disabled:opacity-20"><ArrowLeft className="w-3 h-3" /></button>
                                                <button onClick={() => changeDepth(index, 1)} disabled={file.depth>=2 || index===0} className="text-slate-300 hover:text-slate-600 disabled:opacity-20"><ArrowRight className="w-3 h-3" /></button>
                                            </div>
                                        </div>

                                        <div className="self-center w-8 font-mono font-bold text-slate-400 text-sm">{file.sectionLabel}</div>
                                        
                                        <div className={`flex-1 space-y-2 ${getIndent(file.depth)}`}>
                                            <div className="flex gap-2">
                                                <input type="text" value={file.sectionTitle} onChange={e => updateFileField(file.id, 'sectionTitle', e.target.value)} className="flex-1 font-semibold text-sm bg-transparent border-b border-transparent focus:border-blue-500 outline-none" />
                                                <button onClick={() => setEditingFile(file)} className="p-1 text-slate-400 hover:text-blue-600 bg-slate-50 hover:bg-blue-50 rounded"><FileText className="w-3 h-3" /></button>
                                            </div>
                                            <input type="text" value={file.sectionSubtitle} onChange={e => updateFileField(file.id, 'sectionSubtitle', e.target.value)} className="w-full text-xs text-slate-500 bg-transparent border-b border-transparent focus:border-blue-500 outline-none placeholder-slate-300" placeholder="Subtitle" />
                                            
                                            {!file.isHeader && (
                                                <div className="flex items-center justify-between mt-1 min-h-[20px]">
                                                    <div className="flex items-center gap-2 text-[10px] text-slate-400">
                                                        <span className={`font-medium truncate max-w-[150px] ${(!file.isPlaceholder && !file.fileObj && !file.downloadURL) ? 'text-red-500' : ''}`} title={file.name}>{file.name}</span>
                                                        <span></span>
                                                        <span>{file.pageCount} pgs</span>
                                                    </div>
                                                    
                                                    <label className={`cursor-pointer text-[10px] font-bold uppercase tracking-wider flex items-center gap-1 px-2 py-0.5 rounded transition-colors ${file.isPlaceholder ? 'bg-emerald-50 text-emerald-600 hover:bg-emerald-100' : 'bg-slate-100 text-slate-500 hover:bg-slate-200 hover:text-blue-600'}`}>
                                                        {file.isPlaceholder ? <Upload className="w-3 h-3" /> : <RefreshCw className="w-3 h-3" />}
                                                        <span>{file.isPlaceholder ? "Upload" : "Replace"}</span>
                                                        <input 
                                                            type="file" 
                                                            accept=".pdf" 
                                                            className="hidden" 
                                                            onChange={(e) => file.isPlaceholder ? handleReplacePlaceholder(e, file.id) : handleReplaceFile(e, file.id)} 
                                                            onClick={(e) => e.target.value = null}
                                                        />
                                                    </label>
                                                </div>
                                            )}
                                        </div>
                                        <button onClick={() => removeFile(file.id)} className="self-start text-slate-300 hover:text-red-500 p-1"><Trash2 className="w-4 h-4" /></button>
                                    </li>
                                ))}
                            </ul>
                        </div>

                        {/* 3. Preview Pane (33%) */}
                        <div className="col-span-4 bg-slate-200 h-full border-l border-slate-300 flex flex-col">
                            <div className="flex-none p-2 bg-slate-100 border-b border-slate-200 text-xs text-center text-slate-500 font-medium flex justify-between px-4 items-center">
                                <span>Preview</span>
                                <div className="flex items-center gap-2">
                                    {isProcessing && <span className="flex items-center gap-1 text-blue-600"><Loader2 className="w-3 h-3 animate-spin" /> Generating...</span>}
                                    {pdfData && <button onClick={() => generateBinder('open')} className="p-1 hover:bg-slate-200 rounded text-slate-500 hover:text-blue-600" title="Open in New Tab"><ExternalLink className="w-3 h-3" /></button>}
                                </div>
                            </div>
                            <div className="flex-1 overflow-hidden relative bg-slate-300">
                                {pdfData ? (
                                    <PdfCanvasPreview pdfData={pdfData} />
                                ) : (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center text-slate-400 p-8 text-center">
                                        <Eye className="w-12 h-12 mb-2 opacity-50" />
                                        <p className="text-sm">Preview will appear here automatically.</p>
                                    </div>
                                )}
                            </div>
                        </div>

                    </div>
                </div>
            );
        };

        // Helper function for indentation classes
        const getIndent = (depth) => {
            switch(depth) {
                case 1: return "pl-6 border-l-2 border-slate-100";
                case 2: return "pl-12 border-l-2 border-slate-100";
                default: return "";
            }
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<ErrorBoundary><React.Fragment>{isConfigured ? <CalcBinder /> : <SetupScreen onSave={() => window.location.reload()} />}</React.Fragment></ErrorBoundary>);
    </script>
</body>
</html>
