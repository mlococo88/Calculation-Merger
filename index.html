<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engineering Calculation Merger</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF-Lib Engine (Required for PDF manipulation) -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Font (Noto Sans for consistency) -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Noto Sans', sans-serif; }
    </style>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module">
        // Import React
        import React, { useState, useRef, useMemo, useEffect } from 'https://esm.sh/react@18.2.0';
        import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
        
        // Import Icons
        import { 
            Upload, FileText, ArrowUp, ArrowDown, ArrowRight, ArrowLeft, 
            Trash2, Save, FilePlus, Settings, Eye, AlertCircle, List, 
            Calendar, User, Hash, AlignLeft, AlignCenter, AlignRight, CheckSquare, Clock, 
            Image as ImageIcon, X, FileQuestion, RefreshCw, Cloud, Check, Loader2, WifiOff, Lock, Key, RotateCcw, AlertTriangle, HelpCircle, HardDrive, Database,
            FolderPlus, FolderOpen, MoreVertical, Layout, LogOut, Users, ZapOff, Globe, Book, PenTool, ClipboardList, Type, Copy, GripVertical
        } from 'https://esm.sh/lucide-react@0.263.1';

        // --- FIREBASE IMPORTS (v11.6.1) ---
        import { initializeApp, deleteApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, addDoc, deleteDoc, query, orderBy } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject, listAll, getMetadata, getBytes } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js';

        // --- GLOBAL CONFIGURATION DETECTION ---
        // This allows the app to work in the Canvas environment (auto-config) AND standalone (manual config)
        let firebaseConfig = null;
        let isConfigured = false;
        let isOfflineMode = false;
        let appId = 'default';
        let initialAuthToken = null;

        // 1. Check for Environment Injection
        if (typeof __firebase_config !== 'undefined') {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
                isConfigured = true;
                if (typeof __app_id !== 'undefined') appId = __app_id;
                if (typeof __initial_auth_token !== 'undefined') initialAuthToken = __initial_auth_token;
            } catch(e) { console.error("Env Config Parse Error", e); }
        }

        // 2. Fallback to LocalStorage (Standalone Mode)
        if (!isConfigured) {
            const savedConfig = localStorage.getItem('calcBinder_firebaseConfig');
            if (savedConfig === 'offline') {
                isOfflineMode = true;
                isConfigured = true;
            } else if (savedConfig) {
                try {
                    firebaseConfig = JSON.parse(savedConfig);
                    if (firebaseConfig.apiKey && firebaseConfig.projectId) {
                        isConfigured = true;
                        appId = firebaseConfig.appId || 'default';
                    }
                } catch (e) {
                    localStorage.removeItem('calcBinder_firebaseConfig');
                }
            }
        }

        // --- FIREBASE INITIALIZATION ---
        let app, auth, db, storage;
        if (isConfigured && !isOfflineMode && firebaseConfig) {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                storage = getStorage(app);
            } catch (e) {
                console.error("Firebase Init Failed", e);
                isConfigured = false;
            }
        }

        // --- ERROR BOUNDARY ---
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) { return { hasError: true, error }; }
            handleReset = () => { localStorage.removeItem('calcBinder_firebaseConfig'); window.location.reload(); }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="min-h-screen flex items-center justify-center bg-red-50 p-8 text-center">
                            <div className="bg-white p-8 rounded-lg shadow-xl max-w-md border border-red-100">
                                <AlertTriangle className="w-12 h-12 text-red-500 mx-auto mb-4" />
                                <h1 className="text-xl font-bold text-red-700 mb-2">Critical Error</h1>
                                <div className="bg-slate-100 p-2 rounded text-xs font-mono text-left mb-6 overflow-auto max-h-32">{this.state.error && this.state.error.toString()}</div>
                                <button onClick={this.handleReset} className="w-full py-2 bg-red-600 text-white rounded font-semibold hover:bg-red-700 transition-colors flex items-center justify-center gap-2"><RotateCcw className="w-4 h-4" /> Reset Configuration</button>
                            </div>
                        </div>
                    );
                }
                return this.props.children; 
            }
        }

        // --- COMPONENTS ---

        // Detailed Cover Sheet Modal
        const CoverSheetModal = ({ file, projectMeta, onClose, onSave }) => {
            const [data, setData] = useState({
                sectionTitle: file.sectionTitle || "",
                sectionSubtitle: file.sectionSubtitle || "",
                designedBy: file.designedBy || file.calcsBy || "",
                designedDate: file.designedDate || file.uploadDate || "",
                checkedBy: file.checkedBy || "",
                checkedDate: file.checkedDate || "",
                // Combined Field: QC Review
                qcReviewBy: file.qcReviewBy || file.reviewedBy || file.qcBy || "",
                qcReviewDate: file.qcReviewDate || file.reviewedDate || file.qcDate || "",
                approvedBy: file.approvedBy || "",
                approvedDate: file.approvedDate || "",
                revision: file.revision || "0",
                calcNo: file.calcNo || "",
            });

            // Universal Technical Fields
            const [customFields, setCustomFields] = useState((file.customFields || [
                { id: 1, label: "Objective / Scope", value: file.objective || "", isVisible: true },
                { id: 2, label: "Design Code / References", value: file.references || "", isVisible: true },
                { id: 3, label: "Computer Program", value: file.program || "", isVisible: true },
                { id: 4, label: "Conclusions", value: file.conclusions || "", isVisible: true }
            ]).map(f => ({ ...f, isEditingLabel: false })));

            const handleChange = (field, value) => {
                setData(prev => ({ ...prev, [field]: value }));
            };

            const handleCustomFieldChange = (index, key, val) => {
                const newFields = [...customFields];
                newFields[index][key] = val;
                setCustomFields(newFields);
            };

            const handleSave = () => {
                // Strip UI-only state before saving
                const cleanFields = customFields.map(({ isEditingLabel, ...rest }) => rest);
                onSave(file.id, {
                    ...data,
                    customFields: cleanFields
                });
                onClose();
            };

            const renderSignOffRow = (label, fieldPrefix) => (
                <div className="grid grid-cols-12 gap-2 items-center">
                    <div className="col-span-4 text-xs font-semibold text-slate-500 uppercase">{label}</div>
                    <div className="col-span-5">
                        <input 
                            type="text" 
                            className="w-full border border-slate-300 rounded p-1.5 text-sm focus:ring-2 focus:ring-blue-500 outline-none" 
                            placeholder="Name/Initials"
                            value={data[`${fieldPrefix}By`]} 
                            onChange={e => handleChange(`${fieldPrefix}By`, e.target.value)} 
                        />
                    </div>
                    <div className="col-span-3">
                        <input 
                            type="date" 
                            className="w-full border border-slate-300 rounded p-1.5 text-sm focus:ring-2 focus:ring-blue-500 outline-none" 
                            value={data[`${fieldPrefix}Date`]} 
                            onChange={e => handleChange(`${fieldPrefix}Date`, e.target.value)} 
                        />
                    </div>
                </div>
            );

            return (
                <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl flex flex-col max-h-[90vh]">
                        {/* Header */}
                        <div className="flex justify-between items-center p-6 border-b border-slate-100 bg-slate-50 rounded-t-xl">
                            <h2 className="text-xl font-bold text-slate-800 flex items-center gap-2">
                                <ClipboardList className="w-6 h-6 text-blue-600" /> 
                                Calculation Cover Sheet
                            </h2>
                            <button onClick={onClose} className="p-2 hover:bg-slate-200 rounded-full transition-colors text-slate-400 hover:text-slate-600">
                                <X className="w-5 h-5" />
                            </button>
                        </div>

                        {/* Body - Scrollable */}
                        <div className="p-6 overflow-y-auto space-y-6">
                            
                            <div className="grid grid-cols-2 gap-4 p-3 bg-blue-50 border border-blue-100 rounded-lg text-sm text-blue-800">
                                <div><span className="font-bold uppercase text-[10px] text-blue-400 block">Project</span> {projectMeta.title}</div>
                                <div><span className="font-bold uppercase text-[10px] text-blue-400 block">Project No</span> {projectMeta.number}</div>
                            </div>

                            {/* Section 1: Identification */}
                            <div className="space-y-4">
                                <h3 className="text-sm font-bold uppercase text-slate-400 tracking-wider border-b border-slate-100 pb-1">Identification</h3>
                                <div className="grid grid-cols-12 gap-4">
                                    <div className="col-span-12">
                                        <label className="block text-xs font-semibold text-slate-500 mb-1">Title</label>
                                        <input type="text" className="w-full border border-slate-300 rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none" value={data.sectionTitle} onChange={e => handleChange('sectionTitle', e.target.value)} />
                                    </div>
                                    <div className="col-span-12">
                                        <label className="block text-xs font-semibold text-slate-500 mb-1">Subtitle / Element</label>
                                        <input type="text" className="w-full border border-slate-300 rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="e.g. Pier 3 Cap Design" value={data.sectionSubtitle} onChange={e => handleChange('sectionSubtitle', e.target.value)} />
                                    </div>
                                </div>
                            </div>

                            {/* Section 2: Universal Technical Details */}
                            <div className="space-y-4">
                                <h3 className="text-sm font-bold uppercase text-slate-400 tracking-wider border-b border-slate-100 pb-1">Technical Details</h3>
                                <div className="space-y-3">
                                    {customFields.map((field, index) => (
                                        <div key={index} className="flex gap-3 items-start bg-slate-50 p-3 rounded-lg border border-slate-100 group">
                                            <div className="pt-3">
                                                <input 
                                                    type="checkbox" 
                                                    checked={field.isVisible} 
                                                    onChange={e => handleCustomFieldChange(index, 'isVisible', e.target.checked)}
                                                    className="w-4 h-4 text-blue-600 rounded border-slate-300 focus:ring-blue-500"
                                                    title={`Include "${field.label}" on Divider Sheet`}
                                                />
                                            </div>
                                            <div className="flex-1 space-y-1">
                                                <div className="flex items-center justify-between h-6">
                                                    {field.isEditingLabel ? (
                                                        <div className="flex items-center gap-2 w-full">
                                                            <input 
                                                                autoFocus
                                                                type="text" 
                                                                value={field.label}
                                                                onChange={e => handleCustomFieldChange(index, 'label', e.target.value)}
                                                                onBlur={() => handleCustomFieldChange(index, 'isEditingLabel', false)}
                                                                onKeyDown={(e) => { if (e.key === 'Enter') handleCustomFieldChange(index, 'isEditingLabel', false) }}
                                                                className="w-full text-xs font-bold text-slate-700 bg-white border border-blue-400 rounded px-1.5 py-0.5 outline-none uppercase tracking-wide shadow-sm"
                                                            />
                                                            <button 
                                                                onMouseDown={(e) => e.preventDefault()}
                                                                onClick={() => handleCustomFieldChange(index, 'isEditingLabel', false)} 
                                                                className="p-1 text-green-600 hover:bg-green-50 rounded"
                                                            >
                                                                <Check className="w-3 h-3" />
                                                            </button>
                                                        </div>
                                                    ) : (
                                                        <div className="flex items-center gap-2">
                                                            <span className={`text-xs font-bold text-slate-500 uppercase tracking-wide select-none ${!field.isVisible && 'opacity-50'}`}>{field.label}</span>
                                                            {field.isVisible && (
                                                                <button 
                                                                    onClick={() => handleCustomFieldChange(index, 'isEditingLabel', true)}
                                                                    className="p-1 text-slate-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors"
                                                                    title="Rename Header"
                                                                >
                                                                    <PenTool className="w-3 h-3" />
                                                                </button>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                                <textarea 
                                                    rows={2} 
                                                    maxLength={2500} // Character Limit
                                                    value={field.value}
                                                    onChange={e => handleCustomFieldChange(index, 'value', e.target.value)}
                                                    className={`w-full border rounded p-2 text-sm outline-none resize-none transition-colors ${!field.isVisible ? 'text-slate-400 bg-slate-100 border-slate-200' : 'bg-white border-slate-300 focus:ring-2 focus:ring-blue-500'}`}
                                                    placeholder="Enter details..."
                                                    disabled={!field.isVisible}
                                                />
                                                {field.isVisible && <div className="text-[10px] text-right text-slate-400">{field.value.length}/2500</div>}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Section 3: Sign-off */}
                            <div className="space-y-4">
                                <h3 className="text-sm font-bold uppercase text-slate-400 tracking-wider border-b border-slate-100 pb-1">Sign-off</h3>
                                <div className="space-y-2 bg-slate-50 p-3 rounded-lg border border-slate-100">
                                    <div className="grid grid-cols-12 gap-2 mb-1 text-[10px] uppercase font-bold text-slate-400">
                                        <div className="col-span-4">Role</div>
                                        <div className="col-span-5">Name</div>
                                        <div className="col-span-3">Date</div>
                                    </div>
                                    {renderSignOffRow("Designed By", "designed")}
                                    {renderSignOffRow("Checked By", "checked")}
                                    {/* Consolidated Field */}
                                    {renderSignOffRow("QC Review By", "qcReview")}
                                    {/* REMOVED APPROVED BY */}
                                </div>
                                <div className="flex items-center gap-2 justify-end">
                                    <label className="text-xs font-semibold text-slate-500">Revision:</label>
                                    <input type="text" className="w-16 border border-slate-300 rounded p-1 text-sm text-center focus:ring-2 focus:ring-blue-500 outline-none" value={data.revision} onChange={e => handleChange('revision', e.target.value)} />
                                </div>
                            </div>
                        </div>

                        {/* Footer */}
                        <div className="p-4 border-t border-slate-200 bg-slate-50 rounded-b-xl flex justify-end gap-2">
                            <button onClick={onClose} className="px-4 py-2 text-slate-600 font-medium hover:bg-slate-200 rounded transition-colors">Cancel</button>
                            <button onClick={handleSave} className="px-4 py-2 bg-blue-600 text-white font-medium hover:bg-blue-700 rounded shadow-sm transition-colors flex items-center gap-2">
                                <Check className="w-4 h-4" /> Save Details
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const CorsHelpModal = ({ onClose }) => (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6 relative">
                    <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button>
                    <h2 className="text-xl font-bold text-slate-900 mb-4 flex items-center gap-2"><Globe className="w-6 h-6 text-blue-600" /> Fixing Download Errors (CORS)</h2>
                    <div className="prose prose-sm text-slate-600 max-h-[60vh] overflow-y-auto">
                        <p>If you see "Failed to fetch" errors when generating PDFs, Google Storage is blocking the browser from downloading the file. You must configure CORS on your bucket.</p>
                        <ol className="list-decimal pl-5 space-y-2">
                            <li>Go to the <a href="https://console.cloud.google.com/" target="_blank" className="text-blue-600 hover:underline">Google Cloud Console</a>.</li>
                            <li>Open the Cloud Shell (terminal icon in top right).</li>
                            <li>Create a config file: <code>nano cors.json</code></li>
                            <li>Paste this configuration:
                                <pre className="bg-slate-100 p-2 rounded text-xs mt-1">
{`[
  {
    "origin": ["*"],
    "method": ["GET"],
    "maxAgeSeconds": 3600
  }
]`}
                                </pre>
                            </li>
                            <li>Save (Ctrl+O, Enter) and Exit (Ctrl+X).</li>
                            <li>Run this command (replace <code>YOUR_BUCKET_NAME</code> with the 'storageBucket' from your config):
                                <pre className="bg-slate-100 p-2 rounded text-xs mt-1 font-bold">gsutil cors set cors.json gs://YOUR_BUCKET_NAME</pre>
                            </li>
                        </ol>
                        <p className="text-xs italic mt-2">Note: This allows any website to download your public files. For tighter security, replace <code>*</code> with your specific domain.</p>
                    </div>
                </div>
            </div>
        );

        const SetupScreen = ({ onSave }) => {
            const [configInput, setConfigInput] = useState('');
            const [error, setError] = useState('');
            const [isTesting, setIsTesting] = useState(false);

            const handleSave = async () => {
                setError('');
                setIsTesting(true);
                try {
                    let input = configInput.trim();
                    input = input.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
                    input = input.replace(/^(const|var|let)\s+\w+\s*=\s*/, '');
                    input = input.replace(/;$/, ''); 

                    let config;
                    try {
                        config = JSON.parse(input);
                    } catch (jsonErr) {
                        try {
                            config = new Function('return ' + input)();
                        } catch (evalErr) {
                            throw new Error("Could not parse text. Ensure you copied the full object { ... }.");
                        }
                    }
                    
                    if (!config || !config.apiKey || !config.projectId) throw new Error("Invalid Config: Missing 'apiKey' or 'projectId'.");

                    // TEST CONNECTION (Using test app to verify before saving)
                    try {
                        const tempApp = initializeApp(config, "testConnectionApp");
                        const tempAuth = getAuth(tempApp);
                        await signInAnonymously(tempAuth);
                        deleteApp(tempApp); 
                    } catch (connErr) {
                         // Only warn, don't block if anonymous auth is simply disabled but API key is valid
                        console.warn("Test connection warning:", connErr);
                        if (connErr.code === 'auth/invalid-api-key') {
                            throw new Error("Invalid API Key. Please check your project settings.");
                        }
                    }

                    localStorage.setItem('calcBinder_firebaseConfig', JSON.stringify(config));
                    onSave();
                } catch (e) {
                    setError(e.message);
                } finally {
                    setIsTesting(false);
                }
            };

            const handleOffline = () => {
                localStorage.setItem('calcBinder_firebaseConfig', 'offline');
                onSave();
            };

            return (
                <div className="min-h-screen bg-slate-50 flex items-center justify-center p-4 font-sans">
                    <div className="bg-white max-w-md w-full p-8 rounded-xl shadow-lg border border-slate-200">
                        <div className="flex justify-center mb-6"><div className="w-16 h-16 bg-blue-50 rounded-full flex items-center justify-center"><Lock className="w-8 h-8 text-blue-600" /></div></div>
                        <h1 className="text-2xl font-bold text-center text-slate-900 mb-2">Connect to Cloud</h1>
                        <p className="text-center text-slate-500 mb-6 text-sm">
                            Paste your <strong>Firebase Config</strong> to enable cloud features.<br/>
                            <span className="text-xs text-slate-400">Ensure Anonymous Auth is enabled in Console.</span>
                        </p>
                        <div className="bg-slate-50 p-4 rounded border border-slate-200 mb-4">
                            <label className="block text-xs font-bold text-slate-400 uppercase mb-2">Firebase Config Object</label>
                            <textarea className="w-full h-32 bg-white border border-slate-300 rounded p-2 text-xs font-mono focus:ring-2 focus:ring-blue-500 outline-none" placeholder='{ "apiKey": "...", "projectId": "...", ... }' value={configInput} onChange={(e) => setConfigInput(e.target.value)} />
                        </div>
                        {error && <div className="flex items-start gap-2 text-red-600 text-xs mb-4 bg-red-50 p-2 rounded"><AlertCircle className="w-4 h-4 mt-0.5 shrink-0" /><span>{error}</span></div>}
                        
                        <div className="space-y-3">
                            <button 
                                onClick={handleSave} 
                                disabled={isTesting}
                                className={`w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg transition-colors flex items-center justify-center gap-2 ${isTesting ? 'opacity-70 cursor-not-allowed' : ''}`}
                            >
                                {isTesting ? <Loader2 className="w-4 h-4 animate-spin" /> : <Key className="w-4 h-4" />} 
                                {isTesting ? "Testing Connection..." : "Verify & Save"}
                            </button>
                            
                            <div className="relative flex py-2 items-center">
                                <div className="flex-grow border-t border-slate-200"></div>
                                <span className="flex-shrink-0 mx-4 text-xs text-slate-400 font-medium">OR</span>
                                <div className="flex-grow border-t border-slate-200"></div>
                            </div>

                            <button onClick={handleOffline} className="w-full py-3 bg-white border-2 border-slate-200 hover:border-slate-300 text-slate-600 font-bold rounded-lg transition-colors flex items-center justify-center gap-2">
                                <ZapOff className="w-4 h-4" /> Skip Setup (Work Offline)
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const CalcBinder = () => {
            const [user, setUser] = useState(null);
            const [syncStatus, setSyncStatus] = useState(isOfflineMode ? 'offline' : 'connecting'); 
            const [authError, setAuthError] = useState(null);
            const [showCorsHelp, setShowCorsHelp] = useState(false);
            const [editingFile, setEditingFile] = useState(null); // File object for modal
            
            // --- Multi-Project State ---
            const [projects, setProjects] = useState([]);
            const [activeProjectId, setActiveProjectId] = useState(null);
            
            // --- Current Project Data ---
            const [files, setFiles] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [storageStats, setStorageStats] = useState({ usedBytes: 0, fileCount: 0 });
            const [refreshStats, setRefreshStats] = useState(0); 

            // --- Drag State ---
            const [dragItem, setDragItem] = useState(null); // { index: number, x: number }
            const [dragOverIndex, setDragOverIndex] = useState(null);
            const [isDraggingFile, setIsDraggingFile] = useState(false);

            const [projectMeta, setProjectMeta] = useState({
                title: "Structural Calculation Package",
                number: "2025-001",
                client: "Client Name",
                date: new Date().toISOString().split('T')[0],
                description: "Structural analysis and design of primary framing members.",
                docType: "CALCULATION PACKAGE" 
            });

            const [logo, setLogo] = useState(null); 
            const [logoUrl, setLogoUrl] = useState(null); 
            const [logoScale, setLogoScale] = useState("1.0"); 
            const [pageNumberPos, setPageNumberPos] = useState('right');

            const [pdfLibLoaded, setPdfLibLoaded] = useState(false);
            const fileInputRef = useRef(null);
            const logoInputRef = useRef(null);

            // Create a Ref to track activeProjectId for listeners without stale closures
            const activeProjectIdRef = useRef(activeProjectId);
            
            // Keep ref in sync
            useEffect(() => {
                activeProjectIdRef.current = activeProjectId;
            }, [activeProjectId]);

            useEffect(() => {
                const loadPdfLib = async () => {
                    if (window.PDFLib) { setPdfLibLoaded(true); return; }
                    try {
                        // PDFLib is loaded via script tag, wait for window check
                        const check = setInterval(() => {
                            if(window.PDFLib) {
                                setPdfLibLoaded(true);
                                clearInterval(check);
                            }
                        }, 500);
                        setTimeout(() => clearInterval(check), 5000);
                    } catch (err) { console.error(err); }
                };
                loadPdfLib();
            }, []);

            // --- AUTH & PROJECTS LISTENER ---
            useEffect(() => {
                if (isOfflineMode) {
                    setProjects([{id: 'offline', projectMeta: { title: "Offline Project" }, lastModified: new Date().toISOString() }]);
                    setActiveProjectId('offline');
                    return;
                }

                // Auth Logic incorporating Custom Tokens (for Canvas) and Anonymous fallback
                const initAuth = async () => {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                         setSyncStatus('offline');
                         setAuthError("Auth Failed: " + error.message);
                    }
                };
                initAuth();

                const unsubscribe = onAuthStateChanged(auth, async (currentUser) => {
                    if (currentUser) {
                        setUser(currentUser);
                        setSyncStatus('synced');
                        setAuthError(null);
                        
                        // Strict Rule: No complex queries. Fetch all projects then sort in memory if needed.
                        const projectsRef = collection(db, "artifacts", appId, "public", "data", "projects");
                        
                        // Using simple query
                        const unsubProjects = onSnapshot(projectsRef, (snapshot) => {
                            const projList = snapshot.docs.map(doc => ({
                                id: doc.id,
                                ...doc.data()
                            })).sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified)); // Sort in memory

                            setProjects(projList);
                            
                            // BUG FIX: Use the REF, not state, to check current selection.
                            // Only auto-select if NO project is selected, OR if the currently selected project was deleted.
                            const currentId = activeProjectIdRef.current;
                            
                            if (projList.length > 0) {
                                if (!currentId) {
                                    // Initial load: select first
                                    setActiveProjectId(projList[0].id);
                                } else {
                                    // Check if current still exists
                                    const stillExists = projList.find(p => p.id === currentId);
                                    if (!stillExists) {
                                        // It was deleted, fallback to first
                                        setActiveProjectId(projList[0].id);
                                    }
                                    // If it exists, DO NOTHING. Keep current selection.
                                }
                            } else if (projList.length === 0) {
                                handleCreateProject(currentUser.uid, "New Shared Project");
                            }
                        }, (error) => {
                            setAuthError("Database Access Denied. Check Rules.");
                        });
                        return () => unsubProjects();
                    }
                });
                return () => unsubscribe();
            }, []);

            // --- ACTIVE PROJECT DATA LISTENER ---
            useEffect(() => {
                if (isOfflineMode || !user || !activeProjectId) return;

                const docRef = doc(db, "artifacts", appId, "public", "data", "projects", activeProjectId);
                const unsubDoc = onSnapshot(docRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        if (data.projectMeta) setProjectMeta(data.projectMeta);
                        if (data.files) {
                            setFiles(currentFiles => {
                                const cloudFiles = data.files || [];
                                return cloudFiles.map(cf => {
                                    const localMatch = currentFiles.find(lf => lf.id === cf.id);
                                    return { 
                                        ...cf, 
                                        fileObj: localMatch?.fileObj || null 
                                    };
                                });
                            });
                        }
                        if (data.logoUrl) setLogoUrl(data.logoUrl);
                        if (data.logoScale !== undefined) setLogoScale(data.logoScale.toString());
                        if (data.pageNumberPos) setPageNumberPos(data.pageNumberPos);
                        setSyncStatus('synced');
                        setRefreshStats(prev => prev + 1); 
                    }
                }, (err) => {
                    console.error("Project fetch error", err);
                });
                return () => unsubDoc();
            }, [user, activeProjectId]);

            // --- Storage Usage ---
            useEffect(() => {
                if (isOfflineMode || !user) return;
                const calculateUsage = async () => {
                    try {
                        const filesRef = ref(storage, `artifacts/${appId}/public/data/files`);
                        // Note: listAll only works if rules allow list. 
                        // If this fails, we just don't show stats.
                        const listResult = await listAll(filesRef);
                        let totalBytes = 0;
                        let count = 0;
                        const metadataPromises = listResult.items.map(itemRef => getMetadata(itemRef));
                        const metaResults = await Promise.all(metadataPromises);
                        metaResults.forEach(meta => { totalBytes += meta.size; count++; });
                        setStorageStats({ usedBytes: totalBytes, fileCount: count });
                    } catch (e) { 
                        // Silent fail for stats
                    }
                };
                calculateUsage();
            }, [user, refreshStats, syncStatus]);

            // --- Auto-Save ---
            useEffect(() => {
                if (isOfflineMode) return; 
                const saveData = async () => {
                    if (user && activeProjectId && syncStatus !== 'connecting' && syncStatus !== 'error') {
                        setSyncStatus('syncing');
                        try {
                            const docRef = doc(db, "artifacts", appId, "public", "data", "projects", activeProjectId);
                            const cleanFiles = files.map(f => {
                                const { fileObj, ...rest } = f; 
                                return rest;
                            });
                            await setDoc(docRef, {
                                projectMeta,
                                files: cleanFiles,
                                logoUrl,
                                logoScale: parseFloat(logoScale) || 1.0,
                                pageNumberPos,
                                lastModified: new Date().toISOString(),
                                modifiedBy: user.uid
                            }, { merge: true });
                            setSyncStatus('synced');
                        } catch (e) {
                            console.error("Cloud save failed", e);
                            setSyncStatus('error');
                        }
                    }
                };
                const timeout = setTimeout(saveData, 2000);
                return () => clearTimeout(timeout);
            }, [files, projectMeta, logoUrl, logoScale, pageNumberPos, user, syncStatus, activeProjectId]);


            // --- PROJECT ACTIONS ---
            const handleCreateProject = async (uid, title = "New Shared Project") => {
                if (isOfflineMode) return;
                if (!uid) return;
                const newProject = {
                    projectMeta: { ...projectMeta, title: title, number: "NEW" },
                    files: [],
                    logoUrl: null,
                    logoScale: 1.0,
                    pageNumberPos: 'right',
                    lastModified: new Date().toISOString(),
                    createdBy: uid
                };
                try {
                    const colRef = collection(db, "artifacts", appId, "public", "data", "projects");
                    const docRef = await addDoc(colRef, newProject);
                    setActiveProjectId(docRef.id);
                } catch(e) { console.error("Create project failed", e); }
            };

            // NEW: COPY PROJECT
            const handleCopyProject = async (e, projectId) => {
                e.stopPropagation();
                if (isOfflineMode) { alert("Copy unavailable in offline mode"); return; }
                
                setIsProcessing(true);
                try {
                    // 1. Get Source
                    const sourceRef = doc(db, "artifacts", appId, "public", "data", "projects", projectId);
                    const sourceSnap = await getDoc(sourceRef);
                    
                    if (!sourceSnap.exists()) throw new Error("Source project not found");
                    const sourceData = sourceSnap.data();

                    // 2. Prepare New Data
                    const newMeta = { 
                        ...sourceData.projectMeta, 
                        title: `${sourceData.projectMeta.title} (Copy)`,
                        number: `${sourceData.projectMeta.number}-CPY`
                    };

                    // 3. Deep Copy Files (Assign new IDs to list items, keep Storage refs)
                    const newFiles = (sourceData.files || []).map(f => ({
                        ...f,
                        id: crypto.randomUUID() // Critical: New List ID so keys don't conflict
                    }));

                    const newProject = {
                        ...sourceData,
                        projectMeta: newMeta,
                        files: newFiles,
                        lastModified: new Date().toISOString(),
                        createdBy: user.uid,
                        originalProjectId: projectId // Traceability
                    };

                    // 4. Save
                    const colRef = collection(db, "artifacts", appId, "public", "data", "projects");
                    const docRef = await addDoc(colRef, newProject);
                    
                    setActiveProjectId(docRef.id);
                } catch (err) {
                    console.error("Copy failed", err);
                    alert("Failed to copy project: " + err.message);
                } finally {
                    setIsProcessing(false);
                }
            };

            const handleDeleteProject = async (projectId, e) => {
                e.stopPropagation();
                if (!confirm("Delete project? Files in cloud storage will REMAIN to protect Shared/Copied projects.")) return;
                
                if (isOfflineMode) { return; }

                const projectToDelete = projects.find(p => p.id === projectId);
                if (!projectToDelete) return;

                try {
                    // NOTE: Auto-delete of cloud files is DISABLED to support Copy/Clone functionality safely.
                    // If we delete the PDF blob, all copied projects referencing it will break.
                    
                    await deleteDoc(doc(db, "artifacts", appId, "public", "data", "projects", projectId));
                    
                    if (projectId === activeProjectId) {
                        const remaining = projects.filter(p => p.id !== projectId);
                        setActiveProjectId(remaining.length > 0 ? remaining[0].id : null);
                    }
                } catch(e) { console.error("Delete failed", e); }
            };

            // --- Handlers ---

            const uploadFileToFirebase = async (file) => {
                if (isOfflineMode || !user) return null;
                // Path Rule compliance: /artifacts/{appId}/public/data/files
                const storagePath = `artifacts/${appId}/public/data/files/${crypto.randomUUID()}-${file.name}`;
                const fileRef = ref(storage, storagePath);
                await uploadBytes(fileRef, file);
                setRefreshStats(prev => prev + 1); 
                const url = await getDownloadURL(fileRef);
                return { url, path: storagePath };
            };

            const deleteFromCloud = async (url) => {
                if (isOfflineMode || !user || !url) return;
                try {
                    if (url.includes('firebasestorage.googleapis.com')) {
                        const fileRef = ref(storage, url);
                        await deleteObject(fileRef);
                        setRefreshStats(prev => prev + 1);
                    }
                } catch (e) { console.warn("Cloud deletion failed", e); }
            };

            // Refactored Upload Logic to support both Input Change and Drag & Drop
            const processFiles = async (fileList) => {
                const uploadedFiles = Array.from(fileList);
                const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                
                if (!isOfflineMode) setSyncStatus('syncing');

                for (const file of uploadedFiles) {
                    let pageCount = 'Calc...', rawPages = 0;
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await window.PDFLib.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                        rawPages = pdf.getPageCount();
                        pageCount = rawPages;
                    } catch (err) { pageCount = 'Err'; }

                    let downloadInfo = { url: null, path: null };
                    if (!isOfflineMode && user) {
                        try { downloadInfo = await uploadFileToFirebase(file); } catch (err) { console.warn("Upload failed"); }
                    }

                    setFiles(prev => [...prev, {
                        id: crypto.randomUUID(),
                        name: file.name,
                        downloadURL: downloadInfo.url,
                        storagePath: downloadInfo.path, 
                        fileObj: file, 
                        sectionTitle: file.name.replace('.pdf', '').replace(/_/g, ' '), 
                        sectionSubtitle: '',
                        calcsBy: '', checkedBy: '', revision: '0', uploadDate: currentDate,
                        pageCount, rawPages,
                        size: (file.size / 1024 / 1024).toFixed(2) + ' MB',
                        depth: 0, isPlaceholder: false,
                        objective: "",
                        program: ""
                    }]);
                }
                if (!isOfflineMode) setSyncStatus('synced');
            };

            const handleFileUpload = (e) => {
                if (e.target.files && e.target.files.length > 0) {
                    processFiles(e.target.files);
                }
            };

            // --- GLOBAL DROP HANDLERS ---
            const handleGlobalDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Check if items are being dragged (files)
                if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
                     // Basic check if it's likely a file drag
                     setIsDraggingFile(true);
                }
            };

            const handleGlobalDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDraggingFile(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    processFiles(e.dataTransfer.files);
                }
            };
            
             // Reset drag state if drag leaves window
             const handleGlobalDragLeave = (e) => {
                // Only if leaving the document
                if (e.relatedTarget === null) {
                    setIsDraggingFile(false);
                }
             }


            const handleZoneDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
            };

            const handleZoneDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDraggingFile(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    processFiles(e.dataTransfer.files);
                }
            };

            const handleLogoUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (file.size > 500 * 1024) { 
                    alert("Logo is too large. Please use a file smaller than 500KB.");
                    return;
                }
                
                const reader = new FileReader();
                reader.onloadend = () => {
                    const base64 = reader.result;
                    setLogoUrl(base64); 
                };
                reader.readAsDataURL(file);
            };

            const handleReplaceFile = async (e, id) => {
                const file = e.target.files[0];
                if (!file) return;
                const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                if (syncStatus !== 'offline') setSyncStatus('syncing');

                let pageCount = 0;
                try {
                    const ab = await file.arrayBuffer();
                    const pdf = await window.PDFLib.PDFDocument.load(ab, { ignoreEncryption: true });
                    pageCount = pdf.getPageCount();
                } catch(err) { console.error(err); }

                const oldFile = files.find(f => f.id === id);
                const oldUrl = oldFile ? oldFile.downloadURL : null;

                let downloadInfo = { url: null, path: null };
                if (!isOfflineMode && user) {
                    try { downloadInfo = await uploadFileToFirebase(file); } catch(e) {}
                }

                // NOTE: We do NOT delete the old file here anymore to be safe with copies.
                // if (downloadInfo.url && oldUrl) await deleteFromCloud(oldUrl);

                setFiles(prev => prev.map(f => {
                    if (f.id !== id) return f;
                    return {
                        ...f,
                        name: file.name,
                        downloadURL: downloadInfo.url,
                        storagePath: downloadInfo.path,
                        fileObj: file,
                        uploadDate: currentDate,
                        size: (file.size / 1024 / 1024).toFixed(2) + ' MB',
                        pageCount, rawPages: pageCount
                    };
                }));
                if (!isOfflineMode) setSyncStatus('synced');
            };

            const handleAddPlaceholder = () => {
                const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                setFiles(prev => [...prev, {
                    id: crypto.randomUUID(), downloadURL: null, fileObj: null,
                    name: "Placeholder Section", sectionTitle: "New Placeholder", sectionSubtitle: "",
                    calcsBy: "", checkedBy: "", revision: "0", uploadDate: currentDate,
                    pageCount: 5, rawPages: 5, size: "N/A", depth: 0, isPlaceholder: true,
                    objective: "", program: ""
                }]);
            };
            
            // --- NEW: Handle Adding Section Header ---
            const handleAddHeader = () => {
                const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                setFiles(prev => [...prev, {
                    id: crypto.randomUUID(), downloadURL: null, fileObj: null,
                    name: "Section Header", sectionTitle: "New Section", sectionSubtitle: "",
                    calcsBy: "", checkedBy: "", revision: "0", uploadDate: currentDate,
                    pageCount: 0, rawPages: 0, size: "N/A", depth: 0, 
                    isPlaceholder: false, 
                    isHeader: true, // Distinct flag
                    objective: "", program: ""
                }]);
            };

            const handleReplacePlaceholder = async (e, id) => {
                const file = e.target.files[0];
                if(!file) return;
                handleReplaceFile(e, id); 
                setFiles(prev => prev.map(f => f.id === id ? { ...f, isPlaceholder: false } : f));
            };
            
            const removeFile = async (id) => {
                // Modified: Only remove from LIST state. 
                // Do NOT delete from Cloud Storage, as other projects might reference this file (Copy).
                setFiles(files.filter(f => f.id !== id));
            };
            
            const removeLogo = () => { setLogoUrl(null); if (logoInputRef.current) logoInputRef.current.value = ""; };
            const updateFileField = (id, field, value) => setFiles(files.map(f => f.id === id ? { ...f, [field]: value } : f));
            const updateMeta = (field, value) => setProjectMeta(prev => ({ ...prev, [field]: value }));
            const updatePlaceholderPages = (id, val) => {
                const count = parseInt(val) || 1;
                setFiles(prev => prev.map(f => f.id === id ? { ...f, pageCount: count, rawPages: count } : f));
            };
            const moveFile = (index, direction) => {
                if ((direction === -1 && index === 0) || (direction === 1 && index === files.length - 1)) return;
                const newFiles = [...files];
                const temp = newFiles[index];
                newFiles[index] = newFiles[index + direction];
                newFiles[index + direction] = temp;
                if (index + direction === 0) newFiles[index + direction].depth = 0;
                setFiles(newFiles);
            };
            const changeDepth = (index, delta) => {
                const newFiles = [...files];
                const newDepth = newFiles[index].depth + delta;
                if (newDepth >= 0 && newDepth <= 2 && !(index === 0 && newDepth > 0)) {
                    newFiles[index].depth = newDepth;
                    setFiles(newFiles);
                }
            };
            
            const handleLogout = () => {
                localStorage.removeItem('calcBinder_firebaseConfig');
                window.location.reload();
            };
            
            const handleUpdateFileDetails = (fileId, newDetails) => {
                setFiles(prev => prev.map(f => f.id === fileId ? { ...f, ...newDetails } : f));
            };

            // --- DRAG HANDLERS ---
            const handleDragStart = (e, index) => {
                setDragItem({ index, x: e.clientX });
                e.dataTransfer.effectAllowed = "move";
                // Optional: set custom drag image
            };

            const handleDragEnter = (e, index) => {
                setDragOverIndex(index);
            };

            const handleDragOver = (e) => {
                e.preventDefault(); // Necessary to allow dropping
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDragEnd = () => {
                setDragItem(null);
                setDragOverIndex(null);
            };

            const handleDrop = (e, index) => {
                e.preventDefault();
                e.stopPropagation(); // CRITICAL: Stop bubbling to global drop handler
                
                // --- FIX: Check if dragging external files first! ---
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    processFiles(e.dataTransfer.files);
                    return;
                }

                if (dragItem === null) return;
                
                const dragIndex = dragItem.index;
                const dropIndex = index;
                
                if (dragIndex === dropIndex) {
                    // Check for indent only
                    const deltaX = e.clientX - dragItem.x;
                    const indentChange = Math.round(deltaX / 40); // 40px threshold
                    if (indentChange !== 0) changeDepth(dragIndex, indentChange);
                    return;
                }

                // Move logic
                const newFiles = [...files];
                const [movedItem] = newFiles.splice(dragIndex, 1);
                
                // Calculate indent change
                const deltaX = e.clientX - dragItem.x;
                const indentChange = Math.round(deltaX / 40); 
                
                let newDepth = movedItem.depth + indentChange;
                newDepth = Math.max(0, Math.min(2, newDepth)); // Clamp 0-2
                movedItem.depth = newDepth;

                newFiles.splice(dropIndex, 0, movedItem);
                setFiles(newFiles);
            };

            const numberedFiles = useMemo(() => {
                let main = 0, sub = 0, subSub = 0;
                return files.map(file => {
                    let label = "";
                    if (file.depth === 0) { main++; sub = 0; subSub = 0; label = `${main}`; } 
                    else if (file.depth === 1) { sub++; subSub = 0; label = `${main}.${sub}`; } 
                    else if (file.depth === 2) { subSub++; label = `${main}.${sub}.${subSub}`; }
                    return { ...file, sectionLabel: label };
                });
            }, [files]);

            // --- HELPER: Measure Wrapped Text Height ---
            const measureWrappedTextHeight = (text, size, font, maxWidth) => {
                if (!text) return 0;
                const words = String(text).split(' ');
                let lines = [], currentLine = words[0];
                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = font.widthOfTextAtSize(`${currentLine} ${word}`, size);
                    if (width < maxWidth) currentLine += ` ${word}`;
                    else { lines.push(currentLine); currentLine = word; }
                }
                lines.push(currentLine);
                return lines.length * (size * 1.3);
            };

            // --- HELPER: Get Wrapped Lines Array ---
            const getWrappedLines = (text, size, font, maxWidth) => {
                if (!text) return [];
                const words = String(text).split(' ');
                let lines = [], currentLine = words[0];
                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = font.widthOfTextAtSize(`${currentLine} ${word}`, size);
                    if (width < maxWidth) {
                        currentLine += ` ${word}`;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
                return lines;
            };

            // Enhanced cleaner to replace newlines with spaces for safety
            const cleanText = (text) => {
                if (!text) return "";
                return String(text)
                    .replace(/[\r\n]+/g, " ") // Replace newlines with spaces
                    .replace(/[\u2018\u2019]/g, "'") // Smart quotes
                    .replace(/[\u201C\u201D]/g, '"') // Smart double quotes
                    .replace(/[\u2013\u2014]/g, '-') // Dashes
                    .replace(/[\u2022]/g, '-')       // Bullets
                    .replace(/[^\x00-\x7F]/g, "");   // Strip non-ASCII
            };

            const drawWrappedText = (page, text, y, size, font, rgb, color = [0,0,0], maxWidth, align = 'center') => {
                if (!text) return;
                const safeText = cleanText(text);
                const { width } = page.getSize();
                const safeWidth = maxWidth || (width - 100);
                const lines = getWrappedLines(safeText, size, font, safeWidth);
                const lineHeight = size * 1.3;
                const centerIndex = (lines.length - 1) / 2;
                lines.forEach((line, i) => {
                    const dy = (centerIndex - i) * lineHeight;
                    const lineY = y + dy;
                    const textWidth = font.widthOfTextAtSize(line, size);
                    let xPos = (width - textWidth) / 2;
                    if (align === 'left') xPos = 50;
                    page.drawText(line, { x: xPos, y: lineY, size: size, font: font, color: rgb(...color) });
                });
            };

            // --- FORMAL DIVIDER GENERATION ---
            const drawFormalDivider = (page, fileData, projectMeta, embeddedLogo, fonts, rgb) => {
                // Safety check wrapper
                try {
                    const { width, height } = page.getSize();
                    const { fontBold, fontRegular } = fonts;
                    const margin = 40;
                    const contentWidth = width - (margin * 2);
                    
                    // Header Grid (Project Info)
                    const headerH = 80;
                    const headerY = height - margin - headerH;
                    page.drawLine({ start: { x: margin, y: headerY }, end: { x: width - margin, y: headerY }, thickness: 1, color: rgb(0,0,0) });

                    // Project Title (Top Left)
                    page.drawText("PROJECT:", { x: margin + 10, y: height - margin - 20, size: 8, font: fontBold, color: rgb(0.5,0.5,0.5) });
                    drawWrappedText(page, projectMeta.title, height - margin - 55, 14, fontBold, rgb, [0,0,0], contentWidth - 200, 'left');

                    // Logo placement
                    if (embeddedLogo) {
                        const logoH = 40;
                        const scale = logoH / embeddedLogo.height;
                        const logoW = embeddedLogo.width * scale;
                        page.drawImage(embeddedLogo, { x: width - margin - logoW - 10, y: height - margin - 10 - logoH, width: logoW, height: logoH });
                    }

                    // Section Info Block
                    const titleY = headerY - 60;
                    drawWrappedText(page, `SECTION ${fileData.sectionLabel}`, titleY, 24, fontBold, rgb, [0,0,0]);
                    drawWrappedText(page, fileData.sectionTitle || "Untitled Section", titleY - 40, 18, fontBold, rgb, [0,0,0]);
                    if (fileData.sectionSubtitle) {
                        drawWrappedText(page, fileData.sectionSubtitle, titleY - 70, 14, fontRegular, rgb, [0.3,0.3,0.3]);
                    }

                    // Body Content (Grid simulation)
                    const bodyStart = titleY - 120;
                    let cursorY = bodyStart;

                    // Helper to draw labelled block
                    const drawBlock = (label, text) => {
                        if (!text) return;
                        // Safety check: stop drawing if we hit the footer
                        if (cursorY < (margin + 65 + 40)) return; 

                        page.drawText(label, { x: margin + 20, y: cursorY, size: 9, font: fontBold, color: rgb(0.5,0.5,0.5) });
                        const safeText = cleanText(text);
                        const lines = getWrappedLines(safeText, 10, fontRegular, contentWidth - 40);
                        
                        lines.forEach((line, i) => {
                            const lineY = cursorY - 15 - (i*12);
                            if (lineY > (margin + 65 + 10)) { // Ensure line doesn't overlap footer
                                page.drawText(line, { x: margin + 20, y: lineY, size: 10, font: fontRegular, color: rgb(0,0,0) });
                            }
                        });
                        cursorY -= (lines.length * 12) + 35; 
                    };

                    // DYNAMIC FIELDS RENDER
                    // Use custom fields if available, otherwise fallback to defaults (Objective/Program)
                    const fieldsToDraw = fileData.customFields || [
                        { label: "OBJECTIVE / SCOPE", value: fileData.objective, isVisible: !!fileData.objective },
                        { label: "COMPUTER PROGRAM", value: fileData.program, isVisible: !!fileData.program }
                    ];

                    fieldsToDraw.forEach(field => {
                        // Added safe navigation for field.label
                        if (field.isVisible && field.value && field.label) {
                            drawBlock(field.label.toUpperCase() + ":", field.value);
                        }
                    });

                    // Footer Sign-off (Standard Engineering Block)
                    // --- CONDITION: Only if not a Header ---
                    if (!fileData.isHeader) {
                        const boxBottom = margin;
                        const boxHeight = 65;
                        const boxTop = boxBottom + boxHeight;

                        // Outer Box
                        page.drawRectangle({
                            x: margin,
                            y: boxBottom,
                            width: contentWidth,
                            height: boxHeight,
                            borderColor: rgb(0, 0, 0),
                            borderWidth: 1,
                        });

                        // --- CHANGED TO 3 COLUMNS ---
                        const colCount = 3;
                        const colW = contentWidth / colCount;

                        // Vertical Separators & Text
                        for (let i = 0; i < colCount; i++) {
                            // Line (except first)
                            if (i > 0) {
                                const lineX = margin + (i * colW);
                                page.drawLine({
                                    start: { x: lineX, y: boxBottom },
                                    end: { x: lineX, y: boxTop },
                                    thickness: 1,
                                    color: rgb(0, 0, 0)
                                });
                            }
                        }
                        
                        const drawFooterCell = (index, label, name, date) => {
                            const cellX = margin + (index * colW) + 4; // padding
                            // Label (Top Left of cell)
                            page.drawText(label, { x: cellX, y: boxTop - 12, size: 6, font: fontBold, color: rgb(0.5, 0.5, 0.5) });
                            // Name (Center-ish)
                            if (name) page.drawText(name, { x: cellX, y: boxTop - 30, size: 9, font: fontRegular, color: rgb(0, 0, 0) });
                            // Date (Bottom)
                            if (date) page.drawText(date, { x: cellX, y: boxBottom + 8, size: 7, font: fontRegular, color: rgb(0.3, 0.3, 0.3) });
                        };

                        drawFooterCell(0, "DESIGNED BY", fileData.designedBy, fileData.designedDate);
                        drawFooterCell(1, "CHECKED BY", fileData.checkedBy, fileData.checkedDate);
                        // --- CONSOLIDATED FIELD ---
                        drawFooterCell(2, "QC REVIEW BY", fileData.qcReviewBy, fileData.qcReviewDate); 
                        
                        if (fileData.revision) {
                            page.drawText(`REV: ${fileData.revision}`, { x: width - margin - 150, y: titleY + 30, size: 10, font: fontBold, color: rgb(0,0,0) });
                        }
                    }
                } catch(err) {
                    console.error("Error drawing divider page:", err);
                    page.drawText("Error generating divider content", { x: 50, y: 50, size: 12, color: rgb(1, 0, 0) });
                }
            };


            const generateBinder = async () => {
                setIsProcessing(true);
                try {
                    const { PDFDocument, StandardFonts, rgb } = window.PDFLib;
                    const mergedPdf = await PDFDocument.create();
                    const fontBold = await mergedPdf.embedFont(StandardFonts.HelveticaBold);
                    const fontRegular = await mergedPdf.embedFont(StandardFonts.Helvetica);
                    const fontOblique = await mergedPdf.embedFont(StandardFonts.HelveticaOblique);
                    const fonts = { fontBold, fontRegular, fontOblique };

                    const parsedScale = parseFloat(logoScale) || 1.0;

                    // --- LOGO EMBEDDING STRATEGY ---
                    let embeddedLogo = null;
                    if (logoUrl) {
                        try {
                            const res = await fetch(logoUrl);
                            const logoBytes = await res.arrayBuffer();
                            const isPng = logoUrl.startsWith('data:image/png');
                            try {
                                embeddedLogo = isPng ? await mergedPdf.embedPng(logoBytes) : await mergedPdf.embedJpg(logoBytes);
                            } catch (e1) {
                                try {
                                    embeddedLogo = isPng ? await mergedPdf.embedJpg(logoBytes) : await mergedPdf.embedPng(logoBytes);
                                } catch (e2) {
                                    console.error("Logo embed error", e2);
                                }
                            }
                        } catch(e) { console.error("Logo fetch failed", e); }
                    }

                    // --- PAGE SIZE (LETTER) ---
                    const LETTER_SIZE = [612, 792];

                    // --- COVER SHEET ---
                    const coverPage = mergedPdf.addPage(LETTER_SIZE);
                    const { width, height } = coverPage.getSize();
                    if (embeddedLogo) {
                        const maxWidth = 250;
                        const baseScale = maxWidth / embeddedLogo.width;
                        const finalDims = embeddedLogo.scale((baseScale > 1 ? 1 : baseScale) * parsedScale);
                        coverPage.drawImage(embeddedLogo, { x: (width - finalDims.width) / 2, y: height - 100 - finalDims.height, width: finalDims.width, height: finalDims.height });
                    }
                    drawWrappedText(coverPage, projectMeta.title.toUpperCase(), height - 250, 24, fontBold, rgb, [0,0,0], width - 100);
                    drawWrappedText(coverPage, `PROJECT NO: ${projectMeta.number}`, height - 300, 14, fontRegular, rgb, [0.4,0.4,0.4], width - 100);
                    drawWrappedText(coverPage, (projectMeta.docType || "CALCULATION PACKAGE").toUpperCase(), height / 2, 18, fontBold, rgb, [0,0,0], width - 100);
                    drawWrappedText(coverPage, "PREPARED FOR:", height - 550, 10, fontBold, rgb, [0.5,0.5,0.5], width - 100);
                    drawWrappedText(coverPage, projectMeta.client, height - 570, 16, fontRegular, rgb, [0,0,0], width - 100);
                    drawWrappedText(coverPage, "DATE:", height - 620, 10, fontBold, rgb, [0.5,0.5,0.5], width - 100);
                    drawWrappedText(coverPage, projectMeta.date, height - 640, 14, fontRegular, rgb, [0,0,0], width - 100);
                    if (projectMeta.description) drawWrappedText(coverPage, projectMeta.description, 100, 10, fontOblique, rgb, [0.3,0.3,0.3], width - 150);

                    // --- TOC ---
                    const fileAnalysis = [];
                    const entriesPerPage = 25; 
                    const tocPageCount = Math.ceil(numberedFiles.length / entriesPerPage) || 1;
                    let runningPageNumber = 1 + tocPageCount + 1; 
                    for (const f of numberedFiles) {
                        const pCount = f.rawPages || 1; 
                        fileAnalysis.push({ ...f, startPage: runningPageNumber + 1 });
                        // Header pages (dividers) still count as a page in numbering logic if we include them
                        runningPageNumber += f.isHeader ? 1 : (1 + pCount);
                    }

                    for (let p = 0; p < tocPageCount; p++) {
                        const tocPage = mergedPdf.addPage(LETTER_SIZE);
                        drawWrappedText(tocPage, "TABLE OF CONTENTS", height - 60, 24, fontBold, rgb, [0,0,0]);
                        const startIdx = p * entriesPerPage;
                        const endIdx = Math.min(startIdx + entriesPerPage, fileAnalysis.length);
                        let yPos = height - 120;
                        for (let i = startIdx; i < endIdx; i++) {
                            const item = fileAnalysis[i];
                            const indent = item.depth === 0 ? 50 : item.depth === 1 ? 70 : 90;
                            const font = item.depth === 0 ? fontBold : fontRegular;
                            const fontSize = item.depth === 0 ? 12 : 11;
                            const maxWidth = width - (indent + 60) - 80;
                            const title = item.sectionTitle || "Untitled";
                            
                            tocPage.drawText(item.sectionLabel, { x: indent, y: yPos, size: fontSize, font });
                            
                            const lines = getWrappedLines(title, fontSize, font, maxWidth);
                            lines.forEach((line, lx) => {
                                tocPage.drawText(line, { x: indent + 60, y: yPos - (lx*14), size: fontSize, font });
                            });
                            
                            const pageNumStr = item.startPage.toString();
                            tocPage.drawText(pageNumStr, { x: width - 50 - font.widthOfTextAtSize(pageNumStr, fontSize), y: yPos, size: fontSize, font });
                            
                            const entryHeight = (lines.length * 14) + 10;
                            yPos -= entryHeight;
                        }
                    }

                    // --- SECTIONS ---
                    for (const f of numberedFiles) {
                        // NEW: FORMAL DIVIDER
                        const divPage = mergedPdf.addPage(LETTER_SIZE);
                        drawFormalDivider(divPage, f, projectMeta, embeddedLogo, fonts, rgb);

                        // If it's a Header, we stop here for this item (Divider Only)
                        if (f.isHeader) continue;

                        if (f.isPlaceholder) {
                            for(let k=0; k < f.rawPages; k++) {
                                const p = mergedPdf.addPage(LETTER_SIZE);
                                drawWrappedText(p, `PLACEHOLDER FOR SECTION ${f.sectionLabel}`, p.getHeight()/2, 18, fontBold, rgb, [0.7,0.7,0.7]);
                            }
                        } else {
                            try {
                                let fileBytes = null;
                                if (f.fileObj) fileBytes = await f.fileObj.arrayBuffer();
                                else if (f.storagePath) { const r = ref(storage, f.storagePath); fileBytes = await getBytes(r); }
                                else if (f.downloadURL) { 
                                    const res = await fetch(f.downloadURL); 
                                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                                    fileBytes = await res.arrayBuffer(); 
                                }

                                if (fileBytes) {
                                    const srcDoc = await PDFDocument.load(fileBytes, { ignoreEncryption: true });
                                    const copied = await mergedPdf.copyPages(srcDoc, srcDoc.getPageIndices());
                                    copied.forEach(p => mergedPdf.addPage(p));
                                }
                            } catch (e) {
                                console.error(e);
                                const errP = mergedPdf.addPage(LETTER_SIZE);
                                errP.drawText(`Error loading file: ${f.name}`, { x: 50, y: 700 });
                                errP.drawText(e.message, { x: 50, y: 680, size: 10, color: rgb(1,0,0) });
                            }
                        }
                    }

                    // --- PAGE NUMBERS ---
                    const totalPages = mergedPdf.getPageCount();
                    for (let i = 1; i < totalPages; i++) {
                        const p = mergedPdf.getPage(i);
                        const { width } = p.getSize();
                        const txt = `${i}`;
                        const txtW = fontRegular.widthOfTextAtSize(txt, 10);
                        let x = pageNumberPos === 'left' ? 50 : pageNumberPos === 'center' ? (width - txtW)/2 : width - 50 - txtW;
                        p.drawText(txt, { x, y: 30, size: 10, font: fontRegular });
                    }

                    const pdfBytes = await mergedPdf.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `Binder_${projectMeta.number}.pdf`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                } catch (e) { 
                    alert("PDF Generation Error: " + e.message + "\n\nIf this is a fetch error, please enable CORS on your bucket."); 
                } finally { setIsProcessing(false); }
            };

            const getIndent = (d) => d === 0 ? '' : d === 1 ? 'pl-8 border-l-4 border-slate-200' : 'pl-16 border-l-4 border-slate-200 ml-4';
            const formatBytes = (bytes, decimals = 2) => { if (!+bytes) return '0 Bytes'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`; };

            return (
                <div 
                    className="min-h-screen bg-slate-50 text-slate-800 font-sans p-8"
                    onDragOver={handleGlobalDragOver}
                    onDrop={handleGlobalDrop}
                    onDragLeave={handleGlobalDragLeave}
                >
                    {editingFile && (
                        <CoverSheetModal 
                            file={editingFile} 
                            projectMeta={projectMeta}
                            onClose={() => setEditingFile(null)}
                            onSave={handleUpdateFileDetails}
                        />
                    )}
                    {showCorsHelp && <CorsHelpModal onClose={() => setShowCorsHelp(false)} />}
                    
                    <div className="max-w-[95%] 2xl:max-w-[1600px] mx-auto pt-4">
                        {/* Header */}
                        <div className="flex justify-between items-end mb-8 border-b border-slate-300 pb-4">
                            <div>
                                <h1 className="text-3xl font-bold text-slate-900 flex items-center gap-2"><FilePlus className="w-8 h-8 text-blue-600" /> CalcBinder <span className="text-slate-400 font-light">Cloud</span></h1>
                                <p className="text-slate-500 mt-1">Combine disparate engineering outputs into a single submission.</p>
                            </div>
                            <div className="flex items-center gap-4">
                                <button onClick={() => setShowCorsHelp(true)} className="flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-medium bg-indigo-50 text-indigo-700 border border-indigo-200 hover:bg-indigo-100 transition-colors"><Globe className="w-4 h-4" /> CORS Help</button>
                                {syncStatus === 'synced' && <div className="flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-medium bg-slate-100 border border-slate-200 text-slate-600" title={`Total Cloud Storage Used: ${formatBytes(storageStats.usedBytes)}`}><Database className="w-4 h-4 text-slate-400" /><span>{formatBytes(storageStats.usedBytes)}</span></div>}
                                {authError && <div className="text-xs text-red-600 bg-red-50 border border-red-200 px-3 py-1.5 rounded-full flex items-center gap-2 animate-pulse"><AlertTriangle className="w-4 h-4" /><span>{authError}</span></div>}
                                <div className={`flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-medium border ${syncStatus === 'synced' ? 'bg-green-50 text-green-700 border-green-200' : 'bg-slate-100 text-slate-500 border-slate-200'}`}>
                                    {syncStatus === 'synced' ? <Check className="w-4 h-4" /> : <Cloud className="w-4 h-4" />}<span>{syncStatus === 'synced' ? 'Saved' : 'Connecting...'}</span>
                                </div>
                                <button onClick={handleLogout} className="p-2 text-slate-400 hover:text-red-500 hover:bg-red-50 rounded-full transition-colors" title="Disconnect & Clear Config"><RotateCcw className="w-5 h-5" /></button>
                            </div>
                        </div>

                        <div className="grid grid-cols-12 gap-8">
                            {/* Project Sidebar */}
                            <div className="col-span-12 md:col-span-3 lg:col-span-2 bg-white rounded-lg shadow-sm border border-slate-200 overflow-hidden flex flex-col h-[calc(100vh-150px)] sticky top-6">
                                <div className="p-4 border-b border-slate-200 bg-slate-50 flex justify-between items-center">
                                    <h2 className="font-semibold text-slate-700 flex items-center gap-2"><Layout className="w-4 h-4" /> Projects</h2>
                                    <button onClick={() => handleCreateProject(user?.uid)} className="p-1 hover:bg-white rounded shadow-sm text-blue-600 transition-colors"><FolderPlus className="w-4 h-4" /></button>
                                </div>
                                <div className="overflow-y-auto flex-1 p-2 space-y-1">
                                    {projects.map(p => (
                                        <div key={p.id} onClick={() => setActiveProjectId(p.id)} className={`p-3 rounded-md text-sm cursor-pointer transition-all flex justify-between group ${activeProjectId === p.id ? 'bg-blue-50 border-blue-200 border text-blue-700' : 'hover:bg-slate-50 text-slate-600 border border-transparent'}`}>
                                            <div className="truncate pr-2">
                                                <div className="font-medium truncate">{p.id === activeProjectId ? (projectMeta.title || "Untitled") : (p.projectMeta?.title || "Untitled")}</div>
                                                <div className="text-[10px] opacity-70">{new Date(p.lastModified).toLocaleDateString()}</div>
                                            </div>
                                            <div className="flex gap-1">
                                                <button onClick={(e) => handleCopyProject(e, p.id)} className="opacity-0 group-hover:opacity-100 p-1 hover:bg-blue-100 hover:text-blue-600 rounded transition-opacity" title="Duplicate Project"><Copy className="w-3 h-3" /></button>
                                                <button onClick={(e) => handleDeleteProject(p.id, e)} className="opacity-0 group-hover:opacity-100 p-1 hover:bg-red-100 hover:text-red-600 rounded transition-opacity" title="Delete Project"><Trash2 className="w-3 h-3" /></button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Main Content Area */}
                            <div className="col-span-12 md:col-span-9 lg:col-span-10 grid grid-cols-1 lg:grid-cols-12 gap-8">
                                <div className="lg:col-span-8 space-y-6">
                                    {/* Project Metadata */}
                                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                                        <div className="grid grid-cols-1 md:grid-cols-12 gap-4">
                                            {/* Logo Uploader */}
                                            <div className="md:col-span-3 flex flex-col items-center justify-center">
                                                <div className="w-full aspect-square bg-slate-50 border-2 border-dashed border-slate-300 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:border-blue-400 hover:bg-blue-50 transition-colors relative group" onClick={() => logoInputRef.current?.click()}>
                                                    {logoUrl ? <><img src={logoUrl} className="w-full h-full object-contain p-2" /><button onClick={(e) => {e.stopPropagation(); removeLogo();}} className="absolute top-1 right-1 p-1 bg-white rounded-full text-slate-500 hover:text-red-500 shadow-sm opacity-0 group-hover:opacity-100"><X className="w-3 h-3" /></button></> : <div className="text-center p-2"><ImageIcon className="w-8 h-8 text-slate-300 mx-auto mb-1" /><span className="text-[10px] text-slate-400 font-medium uppercase">Upload Logo</span></div>}
                                                    <input type="file" accept="image/png, image/jpeg" className="hidden" ref={logoInputRef} onChange={handleLogoUpload} />
                                                </div>
                                                <div className="mt-2 flex items-center justify-center gap-2">
                                                    <label className="text-[10px] font-bold text-slate-400 uppercase">Scale:</label>
                                                    <input type="number" min="0.1" max="5.0" step="0.01" value={logoScale} onChange={(e) => setLogoScale(e.target.value)} className="w-16 text-xs border border-slate-300 rounded px-1 py-0.5 text-center" />
                                                </div>
                                            </div>
                                            {/* Fields */}
                                            <div className="md:col-span-9 grid grid-cols-1 md:grid-cols-2 gap-4">
                                                <div className="md:col-span-2"><label className="block text-xs font-semibold text-slate-500 uppercase mb-1">Project Name</label><input type="text" value={projectMeta.title} onChange={(e) => updateMeta('title', e.target.value)} className="w-full px-3 py-2 text-base font-medium border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                                                <div><label className="block text-xs font-semibold text-slate-500 uppercase mb-1 flex items-center gap-1"><Hash className="w-3 h-3" /> Project Number</label><input type="text" value={projectMeta.number} onChange={(e) => updateMeta('number', e.target.value)} className="w-full px-3 py-2 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                                                <div><label className="block text-xs font-semibold text-slate-500 uppercase mb-1 flex items-center gap-1"><Calendar className="w-3 h-3" /> Date</label><input type="date" value={projectMeta.date} onChange={(e) => updateMeta('date', e.target.value)} className="w-full px-3 py-2 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                                                <div className="md:col-span-2"><label className="block text-xs font-semibold text-slate-500 uppercase mb-1 flex items-center gap-1"><User className="w-3 h-3" /> Client Name</label><input type="text" value={projectMeta.client} onChange={(e) => updateMeta('client', e.target.value)} className="w-full px-3 py-2 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                                                <div className="md:col-span-2"><label className="block text-xs font-semibold text-slate-500 uppercase mb-1 flex items-center gap-1"><AlignLeft className="w-3 h-3" /> Description</label><textarea value={projectMeta.description} onChange={(e) => updateMeta('description', e.target.value)} rows={2} className="w-full px-3 py-2 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 outline-none resize-none" /></div>
                                                <div className="md:col-span-2 mt-2 pt-2 border-t border-slate-100"><label className="block text-xs font-semibold text-slate-500 uppercase mb-1 flex items-center gap-1"><Book className="w-3 h-3" /> Document Type</label><input type="text" value={projectMeta.docType || "CALCULATION PACKAGE"} onChange={(e) => updateMeta('docType', e.target.value)} className="w-full px-3 py-2 text-sm font-medium text-slate-700 bg-slate-50 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Drag & Drop */}
                                    <div className="flex gap-4">
                                        <div 
                                            className={`flex-1 border-2 border-dashed rounded-lg p-8 text-center transition-colors cursor-pointer ${isDraggingFile ? 'border-blue-500 bg-blue-50' : 'border-slate-300 bg-slate-50 hover:bg-blue-50 hover:border-blue-400'}`} 
                                            onClick={() => fileInputRef.current?.click()}
                                            onDragOver={handleZoneDragOver}
                                            onDrop={handleZoneDrop}
                                        >
                                            <input type="file" multiple accept=".pdf" className="hidden" ref={fileInputRef} onChange={handleFileUpload} />
                                            <Upload className={`w-12 h-12 mx-auto mb-3 ${isDraggingFile ? 'text-blue-500' : 'text-slate-400'}`} /><p className="text-lg font-medium text-slate-700">Drop PDFs here to Upload</p><p className="text-sm text-slate-500">{syncStatus === 'offline' ? 'Local memory only (Offline Mode)' : 'Automatically saved to Cloud'}</p>
                                        </div>
                                        <div className="flex-col gap-2 flex">
                                            <div className="w-48 flex-1 border-2 border-dashed border-slate-300 rounded-lg flex flex-col items-center justify-center bg-slate-50 hover:bg-emerald-50 hover:border-emerald-400 transition-colors cursor-pointer group" onClick={handleAddPlaceholder}>
                                                <FileQuestion className="w-6 h-6 text-slate-400 group-hover:text-emerald-500 mb-1 transition-colors" /><p className="text-xs font-medium text-slate-600 group-hover:text-emerald-600">Add Placeholder</p>
                                            </div>
                                            <div className="w-48 flex-1 border-2 border-dashed border-slate-300 rounded-lg flex flex-col items-center justify-center bg-slate-50 hover:bg-violet-50 hover:border-violet-400 transition-colors cursor-pointer group" onClick={handleAddHeader}>
                                                <Type className="w-6 h-6 text-slate-400 group-hover:text-violet-500 mb-1 transition-colors" /><p className="text-xs font-medium text-slate-600 group-hover:text-violet-600">Add Section Header</p>
                                            </div>
                                        </div>
                                    </div>

                                    {/* File List */}
                                    <div className="bg-white rounded-lg shadow-sm border border-slate-200 overflow-hidden">
                                        <ul className="divide-y divide-slate-100">
                                            {numberedFiles.map((file, index) => (
                                                <li 
                                                    key={file.id} 
                                                    className={`p-4 transition-colors flex gap-4 group 
                                                        ${file.isHeader ? 'bg-slate-100 border-l-4 border-slate-400' : (file.isPlaceholder ? 'bg-yellow-50/50' : 'hover:bg-slate-50')}
                                                        ${dragOverIndex === index ? 'border-t-2 border-t-blue-500' : ''}
                                                        ${dragItem?.index === index ? 'opacity-50' : ''}
                                                    `}
                                                    // IMPORTANT: Remove draggable from here to allow text selection
                                                    onDragEnter={(e) => handleDragEnter(e, index)}
                                                    onDragOver={handleDragOver}
                                                    onDragEnd={handleDragEnd}
                                                    onDrop={(e) => handleDrop(e, index)}
                                                >
                                                    {/* Drag Handle - ONLY this is draggable */}
                                                    <div 
                                                        className="cursor-move p-2 text-slate-300 hover:text-slate-500 rounded hover:bg-slate-200 self-center mr-2" 
                                                        title="Drag to reorder"
                                                        draggable
                                                        onDragStart={(e) => {
                                                            // Optional: Set drag image to the whole row
                                                            if (e.dataTransfer.setDragImage) {
                                                                 const row = e.currentTarget.closest('li');
                                                                 if (row) e.dataTransfer.setDragImage(row, 0, 0);
                                                            }
                                                            handleDragStart(e, index);
                                                        }}
                                                        onDragEnd={handleDragEnd} // Need to attach drag end here too
                                                    >
                                                        <GripVertical className="w-5 h-5" />
                                                    </div>

                                                    {/* Arrow Controls (Restored) */}
                                                    <div className="flex flex-col items-center justify-center gap-2 mr-2">
                                                        <div className="flex flex-col">
                                                            <button onClick={() => moveFile(index, -1)} disabled={index === 0} className="p-1 hover:bg-slate-200 rounded text-slate-400 disabled:opacity-20"><ArrowUp className="w-3 h-3" /></button>
                                                            <button onClick={() => moveFile(index, 1)} disabled={index === files.length - 1} className="p-1 hover:bg-slate-200 rounded text-slate-400 disabled:opacity-20"><ArrowDown className="w-3 h-3" /></button>
                                                        </div>
                                                        <div className="flex gap-1">
                                                            <button onClick={() => changeDepth(index, -1)} disabled={file.depth === 0} className="p-1 bg-slate-100 hover:bg-slate-200 rounded text-slate-500 disabled:opacity-30"><ArrowLeft className="w-3 h-3" /></button>
                                                            <button onClick={() => changeDepth(index, 1)} disabled={file.depth >= 2 || index === 0} className="p-1 bg-slate-100 hover:bg-slate-200 rounded text-slate-500 disabled:opacity-30"><ArrowRight className="w-3 h-3" /></button>
                                                        </div>
                                                    </div>

                                                    <div className="flex flex-col justify-start pt-2 w-10 shrink-0"><span className="font-mono font-bold text-slate-500 text-lg">{file.sectionLabel}</span></div>
                                                    <div className={`flex-1 space-y-3 transition-all ${getIndent(file.depth)}`}>
                                                        <div className="flex items-center justify-between">
                                                            <input type="text" value={file.sectionTitle} onChange={(e) => updateFileField(file.id, 'sectionTitle', e.target.value)} className="w-full font-semibold text-slate-800 bg-white border border-slate-200 rounded px-2 py-1 outline-none focus:ring-2 focus:ring-blue-500" />
                                                            {/* Cover Sheet Button */}
                                                            <button 
                                                                onClick={() => setEditingFile(file)}
                                                                className="ml-2 flex items-center gap-1 px-2 py-1 bg-white border border-slate-300 rounded hover:bg-blue-50 hover:border-blue-300 text-slate-500 hover:text-blue-600 transition-colors shadow-sm"
                                                                title="Edit Calculation Cover Sheet"
                                                            >
                                                                <FileText className="w-3 h-3" />
                                                                <span className="text-[10px] font-bold uppercase tracking-wide">Cover Sheet</span>
                                                            </button>
                                                            {file.isPlaceholder && <span className="ml-2 text-[9px] bg-yellow-100 text-yellow-700 px-1.5 py-0.5 rounded font-bold uppercase tracking-wider border border-yellow-200">Placeholder</span>}
                                                            {file.isHeader && <span className="ml-2 text-[9px] bg-slate-200 text-slate-600 px-1.5 py-0.5 rounded font-bold uppercase tracking-wider border border-slate-300">Section Header</span>}
                                                            {!file.isPlaceholder && !file.isHeader && !file.fileObj && !file.downloadURL && <span className="text-[9px] bg-red-100 text-red-700 px-1.5 py-0.5 rounded font-bold uppercase tracking-wider border border-red-200 flex items-center gap-1"><AlertTriangle className="w-3 h-3"/> Missing Source</span>}
                                                        </div>
                                                        <input type="text" value={file.sectionSubtitle} onChange={(e) => updateFileField(file.id, 'sectionSubtitle', e.target.value)} className="w-full text-sm text-slate-600 bg-white border border-slate-200 rounded px-2 py-1 outline-none focus:ring-2 focus:ring-blue-500" placeholder="Subtitle" />
                                                        
                                                        {/* Simple Meta Row */}
                                                        {!file.isHeader && (
                                                            <div className="flex items-center justify-between text-xs text-slate-400">
                                                                <div className="flex items-center gap-2">
                                                                    <FileText className={`w-3 h-3 ${(!file.isPlaceholder && !file.fileObj && !file.downloadURL) ? 'text-red-500' : ''}`} />
                                                                    <span className={`truncate max-w-[200px] ${(!file.isPlaceholder && !file.fileObj && !file.downloadURL) ? 'text-red-600 font-medium' : ''}`} title={file.name}>{file.name}</span>
                                                                    <span className="text-slate-300"></span>
                                                                    {file.isPlaceholder ? (
                                                                        <input type="number" min="1" value={file.pageCount} onChange={(e) => updatePlaceholderPages(file.id, e.target.value)} className="w-12 text-center border rounded px-1" />
                                                                    ) : (
                                                                        <span>{file.pageCount} Pages</span>
                                                                    )}
                                                                    {file.uploadDate && <span className="ml-2 text-slate-400 font-mono text-[10px]" title="Date Uploaded">{file.uploadDate}</span>}
                                                                </div>
                                                                <label className={`flex items-center gap-1 cursor-pointer text-[10px] px-1.5 py-0.5 rounded transition-colors ${(!file.isPlaceholder && !file.fileObj && !file.downloadURL) ? 'bg-red-100 text-red-600 hover:bg-red-200 border border-red-200' : 'text-blue-500 hover:text-blue-700 hover:bg-blue-50'}`} title={(!file.isPlaceholder && !file.fileObj && !file.downloadURL) ? "Link Original File" : "Replace PDF File"}><RefreshCw className="w-3 h-3" /> <span className="font-medium">{(!file.isPlaceholder && !file.fileObj && !file.downloadURL) ? "Link PDF" : (file.isPlaceholder ? "Upload" : "Replace")}</span><input type="file" accept=".pdf" className="hidden" onChange={(e) => file.isPlaceholder ? handleReplacePlaceholder(e, file.id) : handleReplaceFile(e, file.id)} /></label>
                                                            </div>
                                                        )}
                                                    </div>
                                                    <div className="flex items-start pt-1"><button onClick={() => removeFile(file.id)} className="p-2 text-slate-300 hover:text-red-600 rounded"><Trash2 className="w-4 h-4" /></button></div>
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                </div>
                                <div className="lg:col-span-4 space-y-6">
                                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200 sticky top-6">
                                        <h3 className="font-semibold text-slate-800 mb-4 flex items-center gap-2"><Settings className="w-4 h-4" /> Output Configuration</h3>
                                        <div className="space-y-4 mb-6">
                                            <div className="flex items-center justify-between text-sm py-2 border-b border-slate-50"><span className="text-slate-600">Total Sections</span><span className="font-mono font-medium bg-slate-100 px-2 py-0.5 rounded">{files.length}</span></div>
                                            <div className="space-y-2 pt-2">
                                                <div className="flex items-center gap-2"><input type="checkbox" checked disabled className="rounded text-blue-600" /><label className="text-sm text-slate-700">TOC (Auto)</label></div>
                                                <div className="flex items-center gap-2"><input type="checkbox" defaultChecked className="rounded text-blue-600" /><label className="text-sm text-slate-700">Section Dividers</label></div>
                                            </div>
                                            <div className="space-y-2 pt-4 border-t border-slate-100">
                                                <label className="text-xs font-semibold text-slate-500 uppercase">Page Numbering</label>
                                                <div className="flex bg-slate-100 p-1 rounded-md">
                                                    <button onClick={() => setPageNumberPos('left')} className={`flex-1 py-1.5 rounded ${pageNumberPos==='left'?'bg-white shadow text-blue-600':'text-slate-400'}`}><AlignLeft className="w-4 h-4 mx-auto" /></button>
                                                    <button onClick={() => setPageNumberPos('center')} className={`flex-1 py-1.5 rounded ${pageNumberPos==='center'?'bg-white shadow text-blue-600':'text-slate-400'}`}><AlignCenter className="w-4 h-4 mx-auto" /></button>
                                                    <button onClick={() => setPageNumberPos('right')} className={`flex-1 py-1.5 rounded ${pageNumberPos==='right'?'bg-white shadow text-blue-600':'text-slate-400'}`}><AlignRight className="w-4 h-4 mx-auto" /></button>
                                                </div>
                                            </div>
                                        </div>
                                        <button onClick={generateBinder} disabled={files.length === 0 || isProcessing} className={`w-full flex items-center justify-center gap-2 py-3 px-4 rounded-md text-white font-medium transition-all shadow-md ${files.length === 0 || isProcessing ? 'bg-slate-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'}`}>
                                            {isProcessing ? <><Loader2 className="w-5 h-5 animate-spin" /> Compiling...</> : <><Save className="w-5 h-5" /> Download Merged PDF</>}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        // In Canvas mode, isConfigured starts as true if env vars exist, so SetupScreen is skipped.
        // In Standalone mode, isConfigured is false initially, showing SetupScreen.
        root.render(<ErrorBoundary><React.Fragment>{isConfigured ? <CalcBinder /> : <SetupScreen onSave={() => window.location.reload()} />}</React.Fragment></ErrorBoundary>);
    </script>
</body>
</html>
